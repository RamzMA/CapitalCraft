{
  "version": 3,
  "sources": ["../../framer-motion/src/motion/features/animation/index.ts", "../../framer-motion/src/motion/features/animation/exit.ts", "../../framer-motion/src/motion/features/animations.ts", "../../framer-motion/src/events/event-info.ts", "../../framer-motion/src/events/add-pointer-event.ts", "../../framer-motion/src/utils/distance.ts", "../../framer-motion/src/components/AnimatePresence/use-presence.ts", "../../framer-motion/src/render/dom/create-visual-element.ts", "../../framer-motion/src/utils/get-context-window.ts", "../../framer-motion/src/gestures/pan/PanSession.ts", "../../framer-motion/src/gestures/drag/utils/constraints.ts", "../../framer-motion/src/gestures/drag/VisualElementDragControls.ts", "../../framer-motion/src/gestures/drag/index.ts", "../../framer-motion/src/gestures/pan/index.ts", "../../framer-motion/src/motion/features/layout/MeasureLayout.tsx", "../../framer-motion/src/motion/features/drag.ts", "../../framer-motion/src/gestures/hover.ts", "../../framer-motion/src/gestures/focus.ts", "../../framer-motion/src/gestures/press.ts", "../../framer-motion/src/motion/features/viewport/observers.ts", "../../framer-motion/src/motion/features/viewport/index.ts", "../../framer-motion/src/motion/features/gestures.ts", "../../framer-motion/src/motion/features/layout.ts", "../../framer-motion/src/render/components/motion/feature-bundle.ts"],
  "sourcesContent": ["import {\n    createAnimationState,\n    Feature,\n    isAnimationControls,\n    type VisualElement,\n} from \"motion-dom\"\n\nexport class AnimationFeature extends Feature<unknown> {\n    unmountControls?: () => void\n\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */\n    constructor(node: VisualElement) {\n        super(node)\n        node.animationState ||= createAnimationState(node)\n    }\n\n    updateAnimationControlsSubscription() {\n        const { animate } = this.node.getProps()\n        if (isAnimationControls(animate)) {\n            this.unmountControls = animate.subscribe(this.node)\n        }\n    }\n\n    /**\n     * Subscribe any provided AnimationControls to the component's VisualElement\n     */\n    mount() {\n        this.updateAnimationControlsSubscription()\n    }\n\n    update() {\n        const { animate } = this.node.getProps()\n        const { animate: prevAnimate } = this.node.prevProps || {}\n        if (animate !== prevAnimate) {\n            this.updateAnimationControlsSubscription()\n        }\n    }\n\n    unmount() {\n        this.node.animationState!.reset()\n        this.unmountControls?.()\n    }\n}\n", "import { Feature } from \"motion-dom\"\n\nlet id = 0\n\nexport class ExitAnimationFeature extends Feature<unknown> {\n    private id: number = id++\n\n    update() {\n        if (!this.node.presenceContext) return\n\n        const { isPresent, onExitComplete } = this.node.presenceContext\n        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {}\n\n        if (!this.node.animationState || isPresent === prevIsPresent) {\n            return\n        }\n\n        const exitAnimation = this.node.animationState.setActive(\n            \"exit\",\n            !isPresent\n        )\n\n        if (onExitComplete && !isPresent) {\n            exitAnimation.then(() => {\n                onExitComplete(this.id)\n            })\n        }\n    }\n\n    mount() {\n        const { register, onExitComplete } = this.node.presenceContext || {}\n\n        if (onExitComplete) {\n            onExitComplete(this.id)\n        }\n\n        if (register) {\n            this.unmount = register(this.id)\n        }\n    }\n\n    unmount() {}\n}\n", "import { AnimationFeature } from \"./animation\"\nimport { ExitAnimationFeature } from \"./animation/exit\"\nimport { FeaturePackages } from \"./types\"\n\nexport const animations: FeaturePackages = {\n    animation: {\n        Feature: AnimationFeature,\n    },\n    exit: {\n        Feature: ExitAnimationFeature,\n    },\n}\n", "import { EventInfo, isPrimaryPointer } from \"motion-dom\"\n\nexport type EventListenerWithPointInfo = (\n    e: PointerEvent,\n    info: EventInfo\n) => void\n\nexport function extractEventInfo(event: PointerEvent): EventInfo {\n    return {\n        point: {\n            x: event.pageX,\n            y: event.pageY,\n        },\n    }\n}\n\nexport const addPointerInfo = (\n    handler: EventListenerWithPointInfo\n): EventListener => {\n    return (event: PointerEvent) =>\n        isPrimaryPointer(event) && handler(event, extractEventInfo(event))\n}\n", "import { addDomEvent } from \"motion-dom\"\nimport { addPointerInfo, EventListenerWithPointInfo } from \"./event-info\"\n\nexport function addPointerEvent(\n    target: EventTarget,\n    eventName: string,\n    handler: EventListenerWithPointInfo,\n    options?: AddEventListenerOptions\n) {\n    return addDomEvent(target, eventName, addPointerInfo(handler), options)\n}\n", "import { Point } from \"motion-utils\"\n\nexport const distance = (a: number, b: number) => Math.abs(a - b)\n\nexport function distance2D(a: Point, b: Point): number {\n    // Multi-dimensional\n    const xDelta = distance(a.x, b.x)\n    const yDelta = distance(a.y, b.y)\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2)\n}\n", "\"use client\"\n\nimport { useCallback, useContext, useEffect, useId } from \"react\"\nimport {\n    PresenceContext,\n    PresenceContextProps,\n} from \"../../context/PresenceContext\"\n\nexport type SafeToRemove = () => void\n\ntype AlwaysPresent = [true, null]\n\ntype Present = [true]\n\ntype NotPresent = [false, SafeToRemove]\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed from the tree,\n * but `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nexport function usePresence(\n    subscribe: boolean = true\n): AlwaysPresent | Present | NotPresent {\n    const context = useContext(PresenceContext)\n\n    if (context === null) return [true, null]\n\n    const { isPresent, onExitComplete, register } = context\n\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n\n    const id = useId()\n    useEffect(() => {\n        if (subscribe) {\n            return register(id)\n        }\n    }, [subscribe])\n\n    const safeToRemove = useCallback(\n        () => subscribe && onExitComplete && onExitComplete(id),\n        [id, onExitComplete, subscribe]\n    )\n\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true]\n}\n\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nexport function useIsPresent() {\n    return isPresent(useContext(PresenceContext))\n}\n\nexport function isPresent(context: PresenceContextProps | null) {\n    return context === null ? true : context.isPresent\n}\n", "import { HTMLVisualElement, SVGVisualElement } from \"motion-dom\"\nimport { ComponentType, Fragment } from \"react\"\nimport { CreateVisualElement, VisualElementOptions } from \"../types\"\nimport { isSVGComponent } from \"./utils/is-svg-component\"\n\nexport const createDomVisualElement: CreateVisualElement = (\n    Component: string | ComponentType<React.PropsWithChildren<unknown>>,\n    options: VisualElementOptions<HTMLElement | SVGElement>\n) => {\n    /**\n     * Use explicit isSVG override if provided, otherwise auto-detect\n     */\n    const isSVG = options.isSVG ?? isSVGComponent(Component)\n\n    return isSVG\n        ? new SVGVisualElement(options)\n        : new HTMLVisualElement(options, {\n              allowProjection: Component !== Fragment,\n          })\n}\n", "import type { VisualElement } from \"motion-dom\"\n\n// Fixes https://github.com/motiondivision/motion/issues/2270\nexport const getContextWindow = ({ current }: VisualElement<Element>) => {\n    return current ? current.ownerDocument.defaultView : null\n}\n", "import type { EventInfo, PanHandler } from \"motion-dom\"\nimport { cancelFrame, frame, frameData, isPrimaryPointer } from \"motion-dom\"\nimport {\n    millisecondsToSeconds,\n    pipe,\n    Point,\n    secondsToMilliseconds,\n    TransformPoint,\n} from \"motion-utils\"\nimport { addPointerEvent } from \"../../events/add-pointer-event\"\nimport { extractEventInfo } from \"../../events/event-info\"\nimport { distance2D } from \"../../utils/distance\"\n\ninterface PanSessionHandlers {\n    onSessionStart: PanHandler\n    onStart: PanHandler\n    onMove: PanHandler\n    onEnd: PanHandler\n    onSessionEnd: PanHandler\n    resumeAnimation: () => void\n}\n\ninterface PanSessionOptions {\n    transformPagePoint?: TransformPoint\n    dragSnapToOrigin?: boolean\n    distanceThreshold?: number\n    contextWindow?: (Window & typeof globalThis) | null\n    /**\n     * Element being dragged. When provided, scroll events on its\n     * ancestors and window are compensated so the gesture continues\n     * smoothly during scroll.\n     */\n    element?: HTMLElement | null\n}\n\ninterface TimestampedPoint extends Point {\n    timestamp: number\n}\n\nconst overflowStyles = /*#__PURE__*/ new Set([\"auto\", \"scroll\"])\n\n/**\n * @internal\n */\nexport class PanSession {\n    /**\n     * @internal\n     */\n    private history: TimestampedPoint[]\n\n    /**\n     * @internal\n     */\n    private startEvent: PointerEvent | null = null\n\n    /**\n     * @internal\n     */\n    private lastMoveEvent: PointerEvent | null = null\n\n    /**\n     * @internal\n     */\n    private lastMoveEventInfo: EventInfo | null = null\n\n    /**\n     * @internal\n     */\n    private transformPagePoint?: TransformPoint\n\n    /**\n     * @internal\n     */\n    private handlers: Partial<PanSessionHandlers> = {}\n\n    /**\n     * @internal\n     */\n    private removeListeners: Function\n\n    /**\n     * For determining if an animation should resume after it is interupted\n     *\n     * @internal\n     */\n    private dragSnapToOrigin: boolean\n\n    /**\n     * The distance after which panning should start.\n     *\n     * @internal\n     */\n    private distanceThreshold: number\n\n    /**\n     * @internal\n     */\n    private contextWindow: PanSessionOptions[\"contextWindow\"] = window\n\n    /**\n     * Scroll positions of scrollable ancestors and window.\n     * @internal\n     */\n    private scrollPositions: Map<Element | Window, Point> = new Map()\n\n    /**\n     * Cleanup function for scroll listeners.\n     * @internal\n     */\n    private removeScrollListeners: (() => void) | null = null\n\n    constructor(\n        event: PointerEvent,\n        handlers: Partial<PanSessionHandlers>,\n        {\n            transformPagePoint,\n            contextWindow = window,\n            dragSnapToOrigin = false,\n            distanceThreshold = 3,\n            element,\n        }: PanSessionOptions = {}\n    ) {\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event)) return\n\n        this.dragSnapToOrigin = dragSnapToOrigin\n        this.handlers = handlers\n        this.transformPagePoint = transformPagePoint\n        this.distanceThreshold = distanceThreshold\n        this.contextWindow = contextWindow || window\n\n        const info = extractEventInfo(event)\n        const initialInfo = transformPoint(info, this.transformPagePoint)\n        const { point } = initialInfo\n\n        const { timestamp } = frameData\n\n        this.history = [{ ...point, timestamp }]\n\n        const { onSessionStart } = handlers\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history))\n\n        this.removeListeners = pipe(\n            addPointerEvent(\n                this.contextWindow,\n                \"pointermove\",\n                this.handlePointerMove\n            ),\n            addPointerEvent(\n                this.contextWindow,\n                \"pointerup\",\n                this.handlePointerUp\n            ),\n            addPointerEvent(\n                this.contextWindow,\n                \"pointercancel\",\n                this.handlePointerUp\n            )\n        )\n\n        // Start scroll tracking if element provided\n        if (element) {\n            this.startScrollTracking(element)\n        }\n    }\n\n    /**\n     * Start tracking scroll on ancestors and window.\n     */\n    private startScrollTracking(element: HTMLElement): void {\n        // Store initial scroll positions for scrollable ancestors\n        let current = element.parentElement\n        while (current) {\n            const style = getComputedStyle(current)\n            if (\n                overflowStyles.has(style.overflowX) ||\n                overflowStyles.has(style.overflowY)\n            ) {\n                this.scrollPositions.set(current, {\n                    x: current.scrollLeft,\n                    y: current.scrollTop,\n                })\n            }\n            current = current.parentElement\n        }\n\n        // Track window scroll\n        this.scrollPositions.set(window, {\n            x: window.scrollX,\n            y: window.scrollY,\n        })\n\n        // Capture listener catches element scroll events as they bubble\n        window.addEventListener(\"scroll\", this.onElementScroll, {\n            capture: true,\n            passive: true,\n        })\n\n        // Direct window scroll listener (window scroll doesn't bubble)\n        window.addEventListener(\"scroll\", this.onWindowScroll, {\n            passive: true,\n        })\n\n        this.removeScrollListeners = () => {\n            window.removeEventListener(\"scroll\", this.onElementScroll, {\n                capture: true,\n            })\n            window.removeEventListener(\"scroll\", this.onWindowScroll)\n        }\n    }\n\n    private onElementScroll = (event: Event): void => {\n        this.handleScroll(event.target as Element)\n    }\n\n    private onWindowScroll = (): void => {\n        this.handleScroll(window)\n    }\n\n    /**\n     * Handle scroll compensation during drag.\n     *\n     * For element scroll: adjusts history origin since pageX/pageY doesn't change.\n     * For window scroll: adjusts lastMoveEventInfo since pageX/pageY would change.\n     */\n    private handleScroll(target: Element | Window): void {\n        const initial = this.scrollPositions.get(target)\n        if (!initial) return\n\n        const isWindow = target === window\n        const current = isWindow\n            ? { x: window.scrollX, y: window.scrollY }\n            : {\n                  x: (target as Element).scrollLeft,\n                  y: (target as Element).scrollTop,\n              }\n\n        const delta = { x: current.x - initial.x, y: current.y - initial.y }\n        if (delta.x === 0 && delta.y === 0) return\n\n        if (isWindow) {\n            // Window scroll: pageX/pageY changes, so update lastMoveEventInfo\n            if (this.lastMoveEventInfo) {\n                this.lastMoveEventInfo.point.x += delta.x\n                this.lastMoveEventInfo.point.y += delta.y\n            }\n        } else {\n            // Element scroll: pageX/pageY unchanged, so adjust history origin\n            if (this.history.length > 0) {\n                this.history[0].x -= delta.x\n                this.history[0].y -= delta.y\n            }\n        }\n\n        this.scrollPositions.set(target, current)\n        frame.update(this.updatePoint, true)\n    }\n\n    private updatePoint = () => {\n        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return\n\n        const info = getPanInfo(this.lastMoveEventInfo, this.history)\n        const isPanStarted = this.startEvent !== null\n\n        // Only start panning if the offset is larger than 3 pixels. If we make it\n        // any larger than this we'll want to reset the pointer history\n        // on the first update to avoid visual snapping to the cursor.\n        const isDistancePastThreshold =\n            distance2D(info.offset, { x: 0, y: 0 }) >= this.distanceThreshold\n\n        if (!isPanStarted && !isDistancePastThreshold) return\n\n        const { point } = info\n        const { timestamp } = frameData\n        this.history.push({ ...point, timestamp })\n\n        const { onStart, onMove } = this.handlers\n\n        if (!isPanStarted) {\n            onStart && onStart(this.lastMoveEvent, info)\n            this.startEvent = this.lastMoveEvent\n        }\n\n        onMove && onMove(this.lastMoveEvent, info)\n    }\n\n    private handlePointerMove = (event: PointerEvent, info: EventInfo) => {\n        this.lastMoveEvent = event\n        this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint)\n\n        // Throttle mouse move event to once per frame\n        frame.update(this.updatePoint, true)\n    }\n\n    private handlePointerUp = (event: PointerEvent, info: EventInfo) => {\n        this.end()\n\n        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers\n\n        // Resume animation if dragSnapToOrigin is set OR if no drag started (user just clicked)\n        // This ensures constraint animations continue when interrupted by a click\n        if (this.dragSnapToOrigin || !this.startEvent) {\n            resumeAnimation && resumeAnimation()\n        }\n        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return\n\n        const panInfo = getPanInfo(\n            event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint),\n            this.history\n        )\n\n        if (this.startEvent && onEnd) {\n            onEnd(event, panInfo)\n        }\n\n        onSessionEnd && onSessionEnd(event, panInfo)\n    }\n\n    updateHandlers(handlers: Partial<PanSessionHandlers>) {\n        this.handlers = handlers\n    }\n\n    end() {\n        this.removeListeners && this.removeListeners()\n        this.removeScrollListeners && this.removeScrollListeners()\n        this.scrollPositions.clear()\n        cancelFrame(this.updatePoint)\n    }\n}\n\nfunction transformPoint(\n    info: EventInfo,\n    transformPagePoint?: (point: Point) => Point\n) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info\n}\n\nfunction subtractPoint(a: Point, b: Point): Point {\n    return { x: a.x - b.x, y: a.y - b.y }\n}\n\nfunction getPanInfo({ point }: EventInfo, history: TimestampedPoint[]) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    }\n}\n\nfunction startDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n    return history[0]\n}\n\nfunction lastDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n    return history[history.length - 1]\n}\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n    if (history.length < 2) {\n        return { x: 0, y: 0 }\n    }\n\n    let i = history.length - 1\n    let timestampedPoint: TimestampedPoint | null = null\n    const lastPoint = lastDevicePoint(history)\n    while (i >= 0) {\n        timestampedPoint = history[i]\n        if (\n            lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)\n        ) {\n            break\n        }\n        i--\n    }\n\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 }\n    }\n\n    const time = millisecondsToSeconds(\n        lastPoint.timestamp - timestampedPoint.timestamp\n    )\n    if (time === 0) {\n        return { x: 0, y: 0 }\n    }\n\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    }\n\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0\n    }\n\n    return currentVelocity\n}\n", "import { calcLength, mixNumber, type DragElastic, type ResolvedConstraints } from \"motion-dom\"\nimport {\n    Axis,\n    BoundingBox,\n    Box,\n    progress as calcProgress,\n    clamp,\n    Point,\n} from \"motion-utils\"\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nexport function applyConstraints(\n    point: number,\n    { min, max }: Partial<Axis>,\n    elastic?: Axis\n): number {\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(min, point, elastic.min)\n            : Math.max(point, min)\n    } else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(max, point, elastic.max)\n            : Math.min(point, max)\n    }\n\n    return point\n}\n\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\nexport function calcConstrainedMinPoint(\n    point: number,\n    length: number,\n    progress: number,\n    constraints?: Partial<Axis>,\n    elastic?: Axis\n): number {\n    // Calculate a min point for this axis and apply it to the current pointer\n    const min = point - length * progress\n\n    return constraints ? applyConstraints(min, constraints, elastic) : min\n}\n\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nexport function calcRelativeAxisConstraints(\n    axis: Axis,\n    min?: number,\n    max?: number\n): Partial<Axis> {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max:\n            max !== undefined\n                ? axis.max + max - (axis.max - axis.min)\n                : undefined,\n    }\n}\n\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nexport function calcRelativeConstraints(\n    layoutBox: Box,\n    { top, left, bottom, right }: Partial<BoundingBox>\n): ResolvedConstraints {\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    }\n}\n\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nexport function calcViewportAxisConstraints(\n    layoutAxis: Axis,\n    constraintsAxis: Axis\n) {\n    let min = constraintsAxis.min - layoutAxis.min\n    let max = constraintsAxis.max - layoutAxis.max\n\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (\n        constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min\n    ) {\n        ;[min, max] = [max, min]\n    }\n\n    return { min, max }\n}\n\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nexport function calcViewportConstraints(layoutBox: Box, constraintsBox: Box) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    }\n}\n\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nexport function calcOrigin(source: Axis, target: Axis): number {\n    let origin = 0.5\n    const sourceLength = calcLength(source)\n    const targetLength = calcLength(target)\n\n    if (targetLength > sourceLength) {\n        origin = calcProgress(target.min, target.max - sourceLength, source.min)\n    } else if (sourceLength > targetLength) {\n        origin = calcProgress(source.min, source.max - targetLength, target.min)\n    }\n\n    return clamp(0, 1, origin)\n}\n\n/**\n * Calculate the relative progress of one constraints box relative to another.\n * Imagine a page scroll bar. At the top, this would return 0, at the bottom, 1.\n * Anywhere in-between, a value between 0 and 1.\n *\n * This also handles flipped constraints, for instance a draggable container within\n * a smaller viewport like a scrollable view.\n */\nexport function calcProgressWithinConstraints(\n    layoutBox: Box,\n    constraintsBox: Box\n): Point {\n    return {\n        x: calcOrigin(layoutBox.x, constraintsBox.x),\n        y: calcOrigin(layoutBox.y, constraintsBox.y),\n    }\n}\n\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\nexport function calcPositionFromProgress(\n    axis: Axis,\n    constraints: Axis,\n    progress: number\n): Axis {\n    const axisLength = axis.max - axis.min\n    const min = mixNumber(\n        constraints.min,\n        constraints.max - axisLength,\n        progress\n    )\n    return { min, max: min + axisLength }\n}\n\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nexport function rebaseAxisConstraints(\n    layout: Axis,\n    constraints: Partial<Axis>\n): Partial<Axis> {\n    const relativeConstraints: Partial<Axis> = {}\n\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min\n    }\n\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min\n    }\n\n    return relativeConstraints\n}\n\nexport const defaultElastic = 0.35\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nexport function resolveDragElastic(\n    dragElastic: DragElastic = defaultElastic\n): Box {\n    if (dragElastic === false) {\n        dragElastic = 0\n    } else if (dragElastic === true) {\n        dragElastic = defaultElastic\n    }\n\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    }\n}\n\nexport function resolveAxisElastic(\n    dragElastic: DragElastic,\n    minLabel: string,\n    maxLabel: string\n): Axis {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    }\n}\n\nexport function resolvePointElastic(\n    dragElastic: DragElastic,\n    label: string\n): number {\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : dragElastic[label as keyof typeof dragElastic] || 0\n}\n", "import {\n    addValueToWillChange,\n    animateMotionValue,\n    calcLength,\n    convertBoundingBoxToBox,\n    convertBoxToBoundingBox,\n    createBox,\n    eachAxis,\n    frame,\n    isElementKeyboardAccessible,\n    measurePageBox,\n    mixNumber,\n    PanInfo,\n    percent,\n    ResolvedConstraints,\n    setDragLock,\n    Transition,\n    type VisualElement,\n} from \"motion-dom\"\nimport { Axis, Point, invariant } from \"motion-utils\"\nimport { addDomEvent, type LayoutUpdateData } from \"motion-dom\"\nimport { addPointerEvent } from \"../../events/add-pointer-event\"\nimport { extractEventInfo } from \"../../events/event-info\"\nimport { MotionProps } from \"../../motion/types\"\nimport { getContextWindow } from \"../../utils/get-context-window\"\nimport { isRefObject } from \"../../utils/is-ref-object\"\nimport { PanSession } from \"../pan/PanSession\"\nimport {\n    applyConstraints,\n    calcOrigin,\n    calcRelativeConstraints,\n    calcViewportConstraints,\n    defaultElastic,\n    rebaseAxisConstraints,\n    resolveDragElastic,\n} from \"./utils/constraints\"\n\nexport const elementDragControls = new WeakMap<\n    VisualElement,\n    VisualElementDragControls\n>()\n\nexport interface DragControlOptions {\n    /**\n     * This distance after which dragging starts and a direction is locked in.\n     *\n     * @public\n     */\n    distanceThreshold?: number\n\n    /**\n     * Whether to immediately snap to the cursor when dragging starts.\n     *\n     * @public\n     */\n    snapToCursor?: boolean\n}\n\ntype DragDirection = \"x\" | \"y\"\n\nexport class VisualElementDragControls {\n    private visualElement: VisualElement<HTMLElement>\n\n    private panSession?: PanSession\n\n    private openDragLock: VoidFunction | null = null\n\n    isDragging = false\n    private currentDirection: DragDirection | null = null\n\n    private originPoint: Point = { x: 0, y: 0 }\n\n    /**\n     * The permitted boundaries of travel, in pixels.\n     */\n    private constraints: ResolvedConstraints | false = false\n\n    private hasMutatedConstraints = false\n\n    /**\n     * The per-axis resolved elastic values.\n     */\n    private elastic = createBox()\n\n    /**\n     * The latest pointer event. Used as fallback when the `cancel` and `stop` functions are called without arguments.\n     */\n    private latestPointerEvent: PointerEvent | null = null\n\n    /**\n     * The latest pan info. Used as fallback when the `cancel` and `stop` functions are called without arguments.\n     */\n    private latestPanInfo: PanInfo | null = null\n\n    constructor(visualElement: VisualElement<HTMLElement>) {\n        this.visualElement = visualElement\n    }\n\n    start(\n        originEvent: PointerEvent,\n        { snapToCursor = false, distanceThreshold }: DragControlOptions = {}\n    ) {\n        /**\n         * Don't start dragging if this component is exiting\n         */\n        const { presenceContext } = this.visualElement\n        if (presenceContext && presenceContext.isPresent === false) return\n\n        const onSessionStart = (event: PointerEvent) => {\n            // Stop or pause animations based on context:\n            // - snapToCursor: stop because we'll set new position values\n            // - otherwise: pause to allow resume if no drag starts (for constraint animations)\n            if (snapToCursor) {\n                this.stopAnimation()\n                this.snapToCursor(extractEventInfo(event).point)\n            } else {\n                this.pauseAnimation()\n            }\n        }\n\n        const onStart = (event: PointerEvent, info: PanInfo) => {\n            // Stop any paused animation so motion values reflect true current position\n            // (pauseAnimation was called in onSessionStart to allow resume if no drag started)\n            this.stopAnimation()\n\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            const { drag, dragPropagation, onDragStart } = this.getProps()\n\n            if (drag && !dragPropagation) {\n                if (this.openDragLock) this.openDragLock()\n\n                this.openDragLock = setDragLock(drag)\n\n                // If we don 't have the lock, don't start dragging\n                if (!this.openDragLock) return\n            }\n\n            this.latestPointerEvent = event\n            this.latestPanInfo = info\n            this.isDragging = true\n\n            this.currentDirection = null\n\n            this.resolveConstraints()\n\n            if (this.visualElement.projection) {\n                this.visualElement.projection.isAnimationBlocked = true\n                this.visualElement.projection.target = undefined\n            }\n\n            /**\n             * Record gesture origin and pointer offset\n             */\n            eachAxis((axis) => {\n                let current = this.getAxisMotionValue(axis).get() || 0\n\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */\n                if (percent.test(current)) {\n                    const { projection } = this.visualElement\n\n                    if (projection && projection.layout) {\n                        const measuredAxis = projection.layout.layoutBox[axis]\n\n                        if (measuredAxis) {\n                            const length = calcLength(measuredAxis)\n                            current = length * (parseFloat(current) / 100)\n                        }\n                    }\n                }\n\n                this.originPoint[axis] = current\n            })\n\n            // Fire onDragStart event\n            if (onDragStart) {\n                frame.postRender(() => onDragStart(event, info))\n            }\n\n            addValueToWillChange(this.visualElement, \"transform\")\n\n            const { animationState } = this.visualElement\n            animationState && animationState.setActive(\"whileDrag\", true)\n        }\n\n        const onMove = (event: PointerEvent, info: PanInfo) => {\n            this.latestPointerEvent = event\n            this.latestPanInfo = info\n\n            const {\n                dragPropagation,\n                dragDirectionLock,\n                onDirectionLock,\n                onDrag,\n            } = this.getProps()\n\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !this.openDragLock) return\n\n            const { offset } = info\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && this.currentDirection === null) {\n                this.currentDirection = getCurrentDirection(offset)\n\n                // If we've successfully set a direction, notify listener\n                if (this.currentDirection !== null) {\n                    onDirectionLock && onDirectionLock(this.currentDirection)\n                }\n\n                return\n            }\n\n            // Update each point with the latest position\n            this.updateAxis(\"x\", info.point, offset)\n            this.updateAxis(\"y\", info.point, offset)\n\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don't fall out of sync.\n             */\n            this.visualElement.render()\n\n            /**\n             * This must fire after the render call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */\n            onDrag && onDrag(event, info)\n        }\n\n        const onSessionEnd = (event: PointerEvent, info: PanInfo) => {\n            this.latestPointerEvent = event\n            this.latestPanInfo = info\n\n            this.stop(event, info)\n\n            this.latestPointerEvent = null\n            this.latestPanInfo = null\n        }\n\n        const resumeAnimation = () =>\n            eachAxis(\n                (axis) =>\n                    this.getAnimationState(axis) === \"paused\" &&\n                    this.getAxisMotionValue(axis).animation?.play()\n            )\n\n        const { dragSnapToOrigin } = this.getProps()\n        this.panSession = new PanSession(\n            originEvent,\n            {\n                onSessionStart,\n                onStart,\n                onMove,\n                onSessionEnd,\n                resumeAnimation,\n            },\n            {\n                transformPagePoint: this.visualElement.getTransformPagePoint(),\n                dragSnapToOrigin,\n                distanceThreshold,\n                contextWindow: getContextWindow(this.visualElement),\n                element: this.visualElement.current,\n            }\n        )\n    }\n\n    /**\n     * @internal\n     */\n    stop(event?: PointerEvent, panInfo?: PanInfo) {\n        const finalEvent = event || this.latestPointerEvent\n        const finalPanInfo = panInfo || this.latestPanInfo\n\n        const isDragging = this.isDragging\n        this.cancel()\n        if (!isDragging || !finalPanInfo || !finalEvent) return\n\n        const { velocity } = finalPanInfo\n        this.startAnimation(velocity)\n\n        const { onDragEnd } = this.getProps()\n        if (onDragEnd) {\n            frame.postRender(() => onDragEnd(finalEvent, finalPanInfo))\n        }\n    }\n\n    /**\n     * @internal\n     */\n    cancel() {\n        this.isDragging = false\n\n        const { projection, animationState } = this.visualElement\n\n        if (projection) {\n            projection.isAnimationBlocked = false\n        }\n\n        this.endPanSession()\n\n        const { dragPropagation } = this.getProps()\n\n        if (!dragPropagation && this.openDragLock) {\n            this.openDragLock()\n            this.openDragLock = null\n        }\n\n        animationState && animationState.setActive(\"whileDrag\", false)\n    }\n\n    /**\n     * Clean up the pan session without modifying other drag state.\n     * This is used during unmount to ensure event listeners are removed\n     * without affecting projection animations or drag locks.\n     * @internal\n     */\n    endPanSession() {\n        this.panSession && this.panSession.end()\n        this.panSession = undefined\n    }\n\n    private updateAxis(axis: DragDirection, _point: Point, offset?: Point) {\n        const { drag } = this.getProps()\n\n        // If we're not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection)) return\n\n        const axisValue = this.getAxisMotionValue(axis)\n        let next = this.originPoint[axis] + offset[axis]\n\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(\n                next,\n                this.constraints[axis],\n                this.elastic[axis]\n            )\n        }\n\n        axisValue.set(next)\n    }\n\n    private resolveConstraints() {\n        const { dragConstraints, dragElastic } = this.getProps()\n\n        const layout =\n            this.visualElement.projection &&\n            !this.visualElement.projection.layout\n                ? this.visualElement.projection.measure(false)\n                : this.visualElement.projection?.layout\n\n        const prevConstraints = this.constraints\n\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints()\n            }\n        } else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(\n                    layout.layoutBox,\n                    dragConstraints\n                )\n            } else {\n                this.constraints = false\n            }\n        }\n\n        this.elastic = resolveDragElastic(dragElastic)\n\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (\n            prevConstraints !== this.constraints &&\n            layout &&\n            this.constraints &&\n            !this.hasMutatedConstraints\n        ) {\n            eachAxis((axis) => {\n                if (\n                    this.constraints !== false &&\n                    this.getAxisMotionValue(axis)\n                ) {\n                    this.constraints[axis] = rebaseAxisConstraints(\n                        layout.layoutBox[axis],\n                        this.constraints[axis]\n                    )\n                }\n            })\n        }\n    }\n\n    private resolveRefConstraints() {\n        const { dragConstraints: constraints, onMeasureDragConstraints } =\n            this.getProps()\n        if (!constraints || !isRefObject(constraints)) return false\n\n        const constraintsElement = constraints.current as HTMLElement\n\n        invariant(\n            constraintsElement !== null,\n            \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\",\n            \"drag-constraints-ref\"\n        )\n\n        const { projection } = this.visualElement\n\n        // TODO\n        if (!projection || !projection.layout) return false\n\n        const constraintsBox = measurePageBox(\n            constraintsElement,\n            projection.root!,\n            this.visualElement.getTransformPagePoint()\n        )\n\n        let measuredConstraints = calcViewportConstraints(\n            projection.layout.layoutBox,\n            constraintsBox\n        )\n\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            const userConstraints = onMeasureDragConstraints(\n                convertBoxToBoundingBox(measuredConstraints)\n            )\n\n            this.hasMutatedConstraints = !!userConstraints\n\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints)\n            }\n        }\n\n        return measuredConstraints\n    }\n\n    private startAnimation(velocity: Point) {\n        const {\n            drag,\n            dragMomentum,\n            dragElastic,\n            dragTransition,\n            dragSnapToOrigin,\n            onDragTransitionEnd,\n        } = this.getProps()\n\n        const constraints: Partial<ResolvedConstraints> = this.constraints || {}\n\n        const momentumAnimations = eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, this.currentDirection)) {\n                return\n            }\n\n            let transition = (constraints && constraints[axis]) || {}\n\n            if (dragSnapToOrigin) transition = { min: 0, max: 0 }\n\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            const bounceStiffness = dragElastic ? 200 : 1000000\n            const bounceDamping = dragElastic ? 40 : 10000000\n\n            const inertia: Transition = {\n                type: \"inertia\",\n                velocity: dragMomentum ? velocity[axis] : 0,\n                bounceStiffness,\n                bounceDamping,\n                timeConstant: 750,\n                restDelta: 1,\n                restSpeed: 10,\n                ...dragTransition,\n                ...transition,\n            }\n\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return this.startAxisValueAnimation(axis, inertia)\n        })\n\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd)\n    }\n\n    private startAxisValueAnimation(\n        axis: DragDirection,\n        transition: Transition\n    ) {\n        const axisValue = this.getAxisMotionValue(axis)\n\n        addValueToWillChange(this.visualElement, axis)\n\n        return axisValue.start(\n            animateMotionValue(\n                axis,\n                axisValue,\n                0,\n                transition,\n                this.visualElement,\n                false\n            )\n        )\n    }\n\n    private stopAnimation() {\n        eachAxis((axis) => this.getAxisMotionValue(axis).stop())\n    }\n\n    private pauseAnimation() {\n        eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause())\n    }\n\n    private getAnimationState(axis: DragDirection) {\n        return this.getAxisMotionValue(axis).animation?.state\n    }\n\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    private getAxisMotionValue(axis: DragDirection) {\n        const dragKey =\n            `_drag${axis.toUpperCase()}` as `_drag${Uppercase<DragDirection>}`\n        const props = this.visualElement.getProps()\n        const externalMotionValue = props[dragKey]\n\n        return externalMotionValue\n            ? externalMotionValue\n            : this.visualElement.getValue(\n                  axis,\n                  (props.initial\n                      ? props.initial[axis as keyof typeof props.initial]\n                      : undefined) || 0\n              )\n    }\n\n    private snapToCursor(point: Point) {\n        eachAxis((axis) => {\n            const { drag } = this.getProps()\n\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, this.currentDirection)) return\n\n            const { projection } = this.visualElement\n            const axisValue = this.getAxisMotionValue(axis)\n\n            if (projection && projection.layout) {\n                const { min, max } = projection.layout.layoutBox[axis]\n\n                /**\n                 * The layout measurement includes the current transform value,\n                 * so we need to add it back to get the correct snap position.\n                 * This fixes an issue where elements with initial coordinates\n                 * would snap to the wrong position on the first drag.\n                 */\n                const current = axisValue.get() || 0\n\n                axisValue.set(point[axis] - mixNumber(min, max, 0.5) + current)\n            }\n        })\n    }\n\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */\n    scalePositionWithinConstraints() {\n        if (!this.visualElement.current) return\n\n        const { drag, dragConstraints } = this.getProps()\n        const { projection } = this.visualElement\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n            return\n\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */\n        this.stopAnimation()\n\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */\n        const boxProgress = { x: 0, y: 0 }\n        eachAxis((axis) => {\n            const axisValue = this.getAxisMotionValue(axis)\n            if (axisValue && this.constraints !== false) {\n                const latest = axisValue.get()\n                boxProgress[axis] = calcOrigin(\n                    { min: latest, max: latest },\n                    this.constraints[axis] as Axis\n                )\n            }\n        })\n\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */\n        const { transformTemplate } = this.visualElement.getProps()\n        this.visualElement.current.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\"\n        projection.root && projection.root.updateScroll()\n        projection.updateLayout()\n        this.resolveConstraints()\n\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */\n        eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, null)) return\n\n            /**\n             * Calculate a new transform based on the previous box progress\n             */\n            const axisValue = this.getAxisMotionValue(axis)\n            const { min, max } = (this.constraints as ResolvedConstraints)[\n                axis\n            ] as Axis\n            axisValue.set(mixNumber(min, max, boxProgress[axis]))\n        })\n    }\n\n    addListeners() {\n        if (!this.visualElement.current) return\n        elementDragControls.set(this.visualElement, this)\n        const element = this.visualElement.current\n\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        const stopPointerListener = addPointerEvent(\n            element,\n            \"pointerdown\",\n            (event) => {\n                const { drag, dragListener = true } = this.getProps()\n                const target = event.target as Element\n\n                /**\n                 * Only block drag if clicking on a keyboard-accessible child element.\n                 * If the draggable element itself is keyboard-accessible (e.g., motion.button),\n                 * dragging should still work when clicking directly on it.\n                 */\n                const isClickingKeyboardAccessibleChild =\n                    target !== element &&\n                    isElementKeyboardAccessible(target)\n\n                if (drag && dragListener && !isClickingKeyboardAccessibleChild) {\n                    this.start(event)\n                }\n            }\n        )\n\n        const measureDragConstraints = () => {\n            const { dragConstraints } = this.getProps()\n            if (isRefObject(dragConstraints) && dragConstraints.current) {\n                this.constraints = this.resolveRefConstraints()\n            }\n        }\n\n        const { projection } = this.visualElement\n\n        const stopMeasureLayoutListener = projection!.addEventListener(\n            \"measure\",\n            measureDragConstraints\n        )\n\n        if (projection && !projection!.layout) {\n            projection.root && projection.root.updateScroll()\n            projection.updateLayout()\n        }\n\n        frame.read(measureDragConstraints)\n\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        const stopResizeListener = addDomEvent(window, \"resize\", () =>\n            this.scalePositionWithinConstraints()\n        )\n\n        /**\n         * If the element's layout changes, calculate the delta and apply that to\n         * the drag gesture's origin point.\n         */\n        const stopLayoutUpdateListener = projection!.addEventListener(\n            \"didUpdate\",\n            (({ delta, hasLayoutChanged }: LayoutUpdateData) => {\n                if (this.isDragging && hasLayoutChanged) {\n                    eachAxis((axis) => {\n                        const motionValue = this.getAxisMotionValue(axis)\n                        if (!motionValue) return\n\n                        this.originPoint[axis] += delta[axis].translate\n                        motionValue.set(\n                            motionValue.get() + delta[axis].translate\n                        )\n                    })\n\n                    this.visualElement.render()\n                }\n            }) as any\n        )\n\n        return () => {\n            stopResizeListener()\n            stopPointerListener()\n            stopMeasureLayoutListener()\n            stopLayoutUpdateListener && stopLayoutUpdateListener()\n        }\n    }\n\n    getProps(): MotionProps {\n        const props = this.visualElement.getProps()\n        const {\n            drag = false,\n            dragDirectionLock = false,\n            dragPropagation = false,\n            dragConstraints = false,\n            dragElastic = defaultElastic,\n            dragMomentum = true,\n        } = props\n        return {\n            ...props,\n            drag,\n            dragDirectionLock,\n            dragPropagation,\n            dragConstraints,\n            dragElastic,\n            dragMomentum,\n        }\n    }\n}\n\nfunction shouldDrag(\n    direction: DragDirection,\n    drag: boolean | DragDirection | undefined,\n    currentDirection: null | DragDirection\n) {\n    return (\n        (drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction)\n    )\n}\n\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(\n    offset: Point,\n    lockThreshold = 10\n): DragDirection | null {\n    let direction: DragDirection | null = null\n\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\"\n    } else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\"\n    }\n\n    return direction\n}\n\nexport function expectsResolvedDragConstraints({\n    dragConstraints,\n    onMeasureDragConstraints,\n}: MotionProps) {\n    return isRefObject(dragConstraints) && !!onMeasureDragConstraints\n}\n", "import { Feature, type VisualElement } from \"motion-dom\"\nimport { noop } from \"motion-utils\"\nimport { VisualElementDragControls } from \"./VisualElementDragControls\"\n\nexport class DragGesture extends Feature<HTMLElement> {\n    controls: VisualElementDragControls\n\n    removeGroupControls: Function = noop\n    removeListeners: Function = noop\n\n    constructor(node: VisualElement<HTMLElement>) {\n        super(node)\n        this.controls = new VisualElementDragControls(node)\n    }\n\n    mount() {\n        // If we've been provided a DragControls for manual control over the drag gesture,\n        // subscribe this component to it on mount.\n        const { dragControls } = this.node.getProps()\n\n        if (dragControls) {\n            this.removeGroupControls = dragControls.subscribe(this.controls)\n        }\n\n        this.removeListeners = this.controls.addListeners() || noop\n    }\n\n    update() {\n        const { dragControls } = this.node.getProps()\n        const { dragControls: prevDragControls } = this.node.prevProps || {}\n\n        if (dragControls !== prevDragControls) {\n            this.removeGroupControls()\n            if (dragControls) {\n                this.removeGroupControls = dragControls.subscribe(this.controls)\n            }\n        }\n    }\n\n    unmount() {\n        this.removeGroupControls()\n        this.removeListeners()\n        /**\n         * Only clean up the pan session if one exists. We use endPanSession()\n         * instead of cancel() because cancel() also modifies projection animation\n         * state and drag locks, which could interfere with nested drag scenarios.\n         */\n        this.controls.endPanSession()\n    }\n}\n", "import { Feature, frame, type PanInfo } from \"motion-dom\"\nimport { noop } from \"motion-utils\"\nimport { addPointerEvent } from \"../../events/add-pointer-event\"\nimport { getContextWindow } from \"../../utils/get-context-window\"\nimport { PanSession } from \"./PanSession\"\n\ntype PanEventHandler = (event: PointerEvent, info: PanInfo) => void\nconst asyncHandler =\n    (handler?: PanEventHandler) => (event: PointerEvent, info: PanInfo) => {\n        if (handler) {\n            frame.postRender(() => handler(event, info))\n        }\n    }\n\nexport class PanGesture extends Feature<Element> {\n    private session?: PanSession\n\n    private removePointerDownListener: Function = noop\n\n    onPointerDown(pointerDownEvent: PointerEvent) {\n        this.session = new PanSession(\n            pointerDownEvent,\n            this.createPanHandlers(),\n            {\n                transformPagePoint: this.node.getTransformPagePoint(),\n                contextWindow: getContextWindow(this.node),\n            }\n        )\n    }\n\n    createPanHandlers() {\n        const { onPanSessionStart, onPanStart, onPan, onPanEnd } =\n            this.node.getProps()\n\n        return {\n            onSessionStart: asyncHandler(onPanSessionStart),\n            onStart: asyncHandler(onPanStart),\n            onMove: onPan,\n            onEnd: (event: PointerEvent, info: PanInfo) => {\n                delete this.session\n                if (onPanEnd) {\n                    frame.postRender(() => onPanEnd(event, info))\n                }\n            },\n        }\n    }\n\n    mount() {\n        this.removePointerDownListener = addPointerEvent(\n            this.node.current!,\n            \"pointerdown\",\n            (event: PointerEvent) => this.onPointerDown(event)\n        )\n    }\n\n    update() {\n        this.session && this.session.updateHandlers(this.createPanHandlers())\n    }\n\n    unmount() {\n        this.removePointerDownListener()\n        this.session && this.session.end()\n    }\n}\n", "\"use client\"\n\nimport { frame, microtask, globalProjectionState, type VisualElement } from \"motion-dom\"\nimport { Component, useContext } from \"react\"\nimport { usePresence } from \"../../../components/AnimatePresence/use-presence\"\nimport {\n    LayoutGroupContext,\n    LayoutGroupContextProps,\n} from \"../../../context/LayoutGroupContext\"\nimport { SwitchLayoutGroupContext } from \"../../../context/SwitchLayoutGroupContext\"\nimport { MotionProps } from \"../../types\"\n\ninterface MeasureContextProps {\n    layoutGroup: LayoutGroupContextProps\n    switchLayoutGroup?: SwitchLayoutGroupContext\n    isPresent: boolean\n    safeToRemove?: VoidFunction | null\n}\n\ntype MeasureProps = MotionProps &\n    MeasureContextProps & { visualElement: VisualElement }\n\n/**\n * Track whether we've taken any snapshots yet. If not,\n * we can safely skip notification of didUpdate.\n *\n * Difficult to capture in a test but to prevent flickering\n * we must set this to true either on update or unmount.\n * Running `next-env/layout-id` in Safari will show this behaviour if broken.\n */\nlet hasTakenAnySnapshot = false\n\nclass MeasureLayoutWithContext extends Component<MeasureProps> {\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    componentDidMount() {\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } =\n            this.props\n        const { projection } = visualElement\n\n        if (projection) {\n            if (layoutGroup.group) layoutGroup.group.add(projection)\n\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n                switchLayoutGroup.register(projection)\n            }\n\n            if (hasTakenAnySnapshot) {\n                projection.root!.didUpdate()\n            }\n\n            projection.addEventListener(\"animationComplete\", () => {\n                this.safeToRemove()\n            })\n            projection.setOptions({\n                ...projection.options,\n                onExitComplete: () => this.safeToRemove(),\n            })\n        }\n\n        globalProjectionState.hasEverUpdated = true\n    }\n\n    getSnapshotBeforeUpdate(prevProps: MeasureProps) {\n        const { layoutDependency, visualElement, drag, isPresent } = this.props\n        const { projection } = visualElement\n\n        if (!projection) return null\n\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent\n\n        hasTakenAnySnapshot = true\n\n        if (\n            drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined ||\n            prevProps.isPresent !== isPresent\n        ) {\n            projection.willUpdate()\n        } else {\n            this.safeToRemove()\n        }\n\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote()\n            } else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                frame.postRender(() => {\n                    const stack = projection.getStack()\n                    if (!stack || !stack.members.length) {\n                        this.safeToRemove()\n                    }\n                })\n            }\n        }\n\n        return null\n    }\n\n    componentDidUpdate() {\n        const { projection } = this.props.visualElement\n        if (projection) {\n            projection.root!.didUpdate()\n\n            microtask.postRender(() => {\n                if (!projection.currentAnimation && projection.isLead()) {\n                    this.safeToRemove()\n                }\n            })\n        }\n    }\n\n    componentWillUnmount() {\n        const {\n            visualElement,\n            layoutGroup,\n            switchLayoutGroup: promoteContext,\n        } = this.props\n        const { projection } = visualElement\n\n        hasTakenAnySnapshot = true\n\n        if (projection) {\n            projection.scheduleCheckAfterUnmount()\n            if (layoutGroup && layoutGroup.group)\n                layoutGroup.group.remove(projection)\n            if (promoteContext && promoteContext.deregister)\n                promoteContext.deregister(projection)\n        }\n    }\n\n    safeToRemove() {\n        const { safeToRemove } = this.props\n        safeToRemove && safeToRemove()\n    }\n\n    render() {\n        return null\n    }\n}\n\nexport function MeasureLayout(\n    props: MotionProps & { visualElement: VisualElement }\n) {\n    const [isPresent, safeToRemove] = usePresence()\n    const layoutGroup = useContext(LayoutGroupContext)\n\n    return (\n        <MeasureLayoutWithContext\n            {...props}\n            layoutGroup={layoutGroup}\n            switchLayoutGroup={useContext(SwitchLayoutGroupContext)}\n            isPresent={isPresent}\n            safeToRemove={safeToRemove}\n        />\n    )\n}\n", "import { DragGesture } from \"../../gestures/drag\"\nimport { PanGesture } from \"../../gestures/pan\"\nimport { HTMLProjectionNode } from \"../../projection\"\nimport { MeasureLayout } from \"./layout/MeasureLayout\"\nimport { FeaturePackages } from \"./types\"\n\nexport const drag: FeaturePackages = {\n    pan: {\n        Feature: PanGesture,\n    },\n    drag: {\n        Feature: DragGesture,\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout,\n    },\n}\n", "import { Feature, frame, hover, type VisualElement } from \"motion-dom\"\nimport { extractEventInfo } from \"../events/event-info\"\n\nfunction handleHoverEvent(\n    node: VisualElement<Element>,\n    event: PointerEvent,\n    lifecycle: \"Start\" | \"End\"\n) {\n    const { props } = node\n\n    if (node.animationState && props.whileHover) {\n        node.animationState.setActive(\"whileHover\", lifecycle === \"Start\")\n    }\n\n    const eventName = (\"onHover\" + lifecycle) as \"onHoverStart\" | \"onHoverEnd\"\n    const callback = props[eventName]\n    if (callback) {\n        frame.postRender(() => callback(event, extractEventInfo(event)))\n    }\n}\n\nexport class HoverGesture extends Feature<Element> {\n    mount() {\n        const { current } = this.node\n        if (!current) return\n\n        this.unmount = hover(current, (_element, startEvent) => {\n            handleHoverEvent(this.node, startEvent, \"Start\")\n\n            return (endEvent) => handleHoverEvent(this.node, endEvent, \"End\")\n        })\n    }\n\n    unmount() {}\n}\n", "import { Feature, addDomEvent } from \"motion-dom\"\nimport { pipe } from \"motion-utils\"\n\nexport class FocusGesture extends Feature<Element> {\n    private isActive = false\n\n    onFocus() {\n        let isFocusVisible = false\n\n        /**\n         * If this element doesn't match focus-visible then don't\n         * apply whileHover. But, if matches throws that focus-visible\n         * is not a valid selector then in that browser outline styles will be applied\n         * to the element by default and we want to match that behaviour with whileFocus.\n         */\n        try {\n            isFocusVisible = this.node.current!.matches(\":focus-visible\")\n        } catch (e) {\n            isFocusVisible = true\n        }\n\n        if (!isFocusVisible || !this.node.animationState) return\n\n        this.node.animationState.setActive(\"whileFocus\", true)\n        this.isActive = true\n    }\n\n    onBlur() {\n        if (!this.isActive || !this.node.animationState) return\n        this.node.animationState.setActive(\"whileFocus\", false)\n        this.isActive = false\n    }\n\n    mount() {\n        this.unmount = pipe(\n            addDomEvent(this.node.current!, \"focus\", () => this.onFocus()),\n            addDomEvent(this.node.current!, \"blur\", () => this.onBlur())\n        ) as VoidFunction\n    }\n\n    unmount() {}\n}\n", "import { Feature, frame, press, type VisualElement } from \"motion-dom\"\nimport { extractEventInfo } from \"../events/event-info\"\n\nfunction handlePressEvent(\n    node: VisualElement<Element>,\n    event: PointerEvent,\n    lifecycle: \"Start\" | \"End\" | \"Cancel\"\n) {\n    const { props } = node\n\n    if (node.current instanceof HTMLButtonElement && node.current.disabled) {\n        return\n    }\n\n    if (node.animationState && props.whileTap) {\n        node.animationState.setActive(\"whileTap\", lifecycle === \"Start\")\n    }\n\n    const eventName = (\"onTap\" + (lifecycle === \"End\" ? \"\" : lifecycle)) as\n        | \"onTapStart\"\n        | \"onTap\"\n        | \"onTapCancel\"\n\n    const callback = props[eventName]\n    if (callback) {\n        frame.postRender(() => callback(event, extractEventInfo(event)))\n    }\n}\n\nexport class PressGesture extends Feature<Element> {\n    mount() {\n        const { current } = this.node\n        if (!current) return\n\n        this.unmount = press(\n            current,\n            (_element, startEvent) => {\n                handlePressEvent(this.node, startEvent, \"Start\")\n\n                return (endEvent, { success }) =>\n                    handlePressEvent(\n                        this.node,\n                        endEvent,\n                        success ? \"End\" : \"Cancel\"\n                    )\n            },\n            { useGlobalTarget: this.node.props.globalTapTarget }\n        )\n    }\n\n    unmount() {}\n}\n", "type IntersectionHandler = (entry: IntersectionObserverEntry) => void\n\ninterface ElementIntersectionObservers {\n    [key: string]: IntersectionObserver\n}\n\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap<Element, IntersectionHandler>()\n\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap<\n    Element | Document,\n    ElementIntersectionObservers\n>()\n\nconst fireObserverCallback = (entry: IntersectionObserverEntry) => {\n    const callback = observerCallbacks.get(entry.target)\n    callback && callback(entry)\n}\n\nconst fireAllObserverCallbacks: IntersectionObserverCallback = (entries) => {\n    entries.forEach(fireObserverCallback)\n}\n\nfunction initIntersectionObserver({\n    root,\n    ...options\n}: IntersectionObserverInit): IntersectionObserver {\n    const lookupRoot = root || document\n\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {})\n    }\n    const rootObservers = observers.get(lookupRoot)!\n\n    const key = JSON.stringify(options)\n\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(\n            fireAllObserverCallbacks,\n            { root, ...options }\n        )\n    }\n\n    return rootObservers[key]\n}\n\nexport function observeIntersection(\n    element: Element,\n    options: IntersectionObserverInit,\n    callback: IntersectionHandler\n) {\n    const rootInteresectionObserver = initIntersectionObserver(options)\n\n    observerCallbacks.set(element, callback)\n    rootInteresectionObserver.observe(element)\n\n    return () => {\n        observerCallbacks.delete(element)\n        rootInteresectionObserver.unobserve(element)\n    }\n}\n", "import { Feature } from \"motion-dom\"\nimport { MotionProps } from \"../../types\"\nimport { observeIntersection } from \"./observers\"\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n}\n\nexport class InViewFeature extends Feature<Element> {\n    private hasEnteredView = false\n\n    private isInView = false\n\n    private startObserver() {\n        this.unmount()\n\n        const { viewport = {} } = this.node.getProps()\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport\n\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold:\n                typeof amount === \"number\" ? amount : thresholdNames[amount],\n        }\n\n        const onIntersectionUpdate = (entry: IntersectionObserverEntry) => {\n            const { isIntersecting } = entry\n\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting) return\n\n            this.isInView = isIntersecting\n\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return\n            } else if (isIntersecting) {\n                this.hasEnteredView = true\n            }\n\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\n                    \"whileInView\",\n                    isIntersecting\n                )\n            }\n\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps()\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave\n            callback && callback(entry)\n        }\n\n        return observeIntersection(\n            this.node.current!,\n            options,\n            onIntersectionUpdate\n        )\n    }\n\n    mount() {\n        this.startObserver()\n    }\n\n    update() {\n        if (typeof IntersectionObserver === \"undefined\") return\n\n        const { props, prevProps } = this.node\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(\n            hasViewportOptionChanged(props, prevProps)\n        )\n\n        if (hasOptionsChanged) {\n            this.startObserver()\n        }\n    }\n\n    unmount() {}\n}\n\nfunction hasViewportOptionChanged(\n    { viewport = {} }: MotionProps,\n    { viewport: prevViewport = {} }: MotionProps = {}\n) {\n    return (name: keyof typeof viewport) =>\n        viewport[name] !== prevViewport[name]\n}\n", "import { HoverGesture } from \"../../gestures/hover\"\nimport { FocusGesture } from \"../../gestures/focus\"\nimport { PressGesture } from \"../../gestures/press\"\nimport { InViewFeature } from \"./viewport\"\nimport { FeaturePackages } from \"./types\"\n\nexport const gestureAnimations: FeaturePackages = {\n    inView: {\n        Feature: InViewFeature,\n    },\n    tap: {\n        Feature: PressGesture,\n    },\n    focus: {\n        Feature: FocusGesture,\n    },\n    hover: {\n        Feature: HoverGesture,\n    },\n}\n", "import { HTMLProjectionNode } from \"motion-dom\"\nimport { MeasureLayout } from \"./layout/MeasureLayout\"\nimport { FeaturePackages } from \"./types\"\n\nexport const layout: FeaturePackages = {\n    layout: {\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout,\n    },\n}\n", "import { animations } from \"../../../motion/features/animations\"\nimport { drag } from \"../../../motion/features/drag\"\nimport { gestureAnimations } from \"../../../motion/features/gestures\"\nimport { layout } from \"../../../motion/features/layout\"\n\nexport const featureBundle = {\n    ...animations,\n    ...gestureAnimations,\n    ...drag,\n    ...layout,\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOM,IAAO,mBAAP,cAAgC,QAAgB;;;;;;EAQlD,YAAY,MAAmB;AAC3B,UAAM,IAAI;AACV,SAAK,mBAAL,KAAK,iBAAmB,qBAAqB,IAAI;;EAGrD,sCAAmC;AAC/B,UAAM,EAAE,QAAO,IAAK,KAAK,KAAK,SAAQ;AACtC,QAAI,oBAAoB,OAAO,GAAG;AAC9B,WAAK,kBAAkB,QAAQ,UAAU,KAAK,IAAI;;;;;;EAO1D,QAAK;AACD,SAAK,oCAAmC;;EAG5C,SAAM;AACF,UAAM,EAAE,QAAO,IAAK,KAAK,KAAK,SAAQ;AACtC,UAAM,EAAE,SAAS,YAAW,IAAK,KAAK,KAAK,aAAa,CAAA;AACxD,QAAI,YAAY,aAAa;AACzB,WAAK,oCAAmC;;;EAIhD,UAAO;AACH,SAAK,KAAK,eAAgB,MAAK;AAC/B,SAAK,kBAAe;;AAE3B;;;AC5CD,IAAI,KAAK;AAEH,IAAO,uBAAP,cAAoC,QAAgB;EAA1D,cAAA;;AACY,SAAE,KAAW;;EAErB,SAAM;AACF,QAAI,CAAC,KAAK,KAAK;AAAiB;AAEhC,UAAM,EAAE,WAAAA,YAAW,eAAc,IAAK,KAAK,KAAK;AAChD,UAAM,EAAE,WAAW,cAAa,IAAK,KAAK,KAAK,uBAAuB,CAAA;AAEtE,QAAI,CAAC,KAAK,KAAK,kBAAkBA,eAAc,eAAe;AAC1D;;AAGJ,UAAM,gBAAgB,KAAK,KAAK,eAAe,UAC3C,QACA,CAACA,UAAS;AAGd,QAAI,kBAAkB,CAACA,YAAW;AAC9B,oBAAc,KAAK,MAAK;AACpB,uBAAe,KAAK,EAAE;MAC1B,CAAC;;;EAIT,QAAK;AACD,UAAM,EAAE,UAAU,eAAc,IAAK,KAAK,KAAK,mBAAmB,CAAA;AAElE,QAAI,gBAAgB;AAChB,qBAAe,KAAK,EAAE;;AAG1B,QAAI,UAAU;AACV,WAAK,UAAU,SAAS,KAAK,EAAE;;;EAIvC,UAAO;EAAA;AACV;;;ACtCY,IAAA,aAA8B;EACvC,WAAW;IACP,SAAS;EACZ;EACD,MAAM;IACF,SAAS;EACZ;;;;ACHC,SAAU,iBAAiB,OAAmB;AAChD,SAAO;IACH,OAAO;MACH,GAAG,MAAM;MACT,GAAG,MAAM;IACZ;;AAET;AAEa,IAAA,iBAAiB,CAC1B,YACe;AACf,SAAO,CAAC,UACJ,iBAAiB,KAAK,KAAK,QAAQ,OAAO,iBAAiB,KAAK,CAAC;AACzE;;;AClBM,SAAU,gBACZ,QACA,WACA,SACA,SAAiC;AAEjC,SAAO,YAAY,QAAQ,WAAW,eAAe,OAAO,GAAG,OAAO;AAC1E;;;ACRa,IAAA,WAAW,CAAC,GAAW,MAAc,KAAK,IAAI,IAAI,CAAC;AAEhD,SAAA,WAAW,GAAU,GAAQ;AAEzC,QAAM,SAAS,SAAS,EAAE,GAAG,EAAE,CAAC;AAChC,QAAM,SAAS,SAAS,EAAE,GAAG,EAAE,CAAC;AAChC,SAAO,KAAK,KAAK,UAAU,IAAI,UAAU,CAAC;AAC9C;A;;;AC8BgB,SAAA,YAAA,YAAA,MAAA;AAGZ,QAAA,cAAA,yBAAA,eAAA;;AAEsB,WAAA,CAAA,MAAA,IAAA;;AAOtB,QAAAC,UAAA,oBAAA;;;AAGQ,aAAA,SAAAA,GAAA;;EAER,GAAA,CAAA,SAAA,CAAA;;AAOA,SAAA,CAAAC,cAAA,iBAAA,CAAA,OAAA,YAAA,IAAA,CAAA,IAAA;AACJ;;AAuBI,SAAA,cAAA,yBAAA,eAAA,CAAA;AACJ;AAEM,SAAA,UAAA,SAAA;AACF,SAAA,YAAA,OAAA,OAAA,QAAA;AACJ;A;;;ICvFa,yBAA8C,CACvDC,YACA,YACA;AAIA,QAAM,QAAQ,QAAQ,SAAS,eAAeA,UAAS;AAEvD,SAAO,QACD,IAAI,iBAAiB,OAAO,IAC5B,IAAI,kBAAkB,SAAS;IAC3B,iBAAiBA,eAAc;EAClC,CAAA;AACX;;;IChBa,mBAAmB,CAAC,EAAE,QAAO,MAA8B;AACpE,SAAO,UAAU,QAAQ,cAAc,cAAc;AACzD;;;ACkCA,IAAM,iBAA+B,oBAAI,IAAI,CAAC,QAAQ,QAAQ,CAAC;IAKlD,mBAAU;EAmEnB,YACI,OACA,UACA,EACI,oBACA,gBAAgB,QAChB,mBAAmB,OACnB,oBAAoB,GACpB,QAAO,IACY,CAAA,GAAE;AAnErB,SAAU,aAAwB;AAKlC,SAAa,gBAAwB;AAKrC,SAAiB,oBAAqB;AAUtC,SAAQ,WAAgC,CAAA;AAwBxC,SAAa,gBAAuC;AAMpD,SAAA,kBAAgD,oBAAI,IAAG;AAMvD,SAAqB,wBAAwB;AAuG7C,SAAA,kBAAkB,CAACC,WAAsB;AAC7C,WAAK,aAAaA,OAAM,MAAiB;IAC7C;AAEQ,SAAc,iBAAG,MAAW;AAChC,WAAK,aAAa,MAAM;IAC5B;AAyCQ,SAAW,cAAG,MAAK;AACvB,UAAI,EAAE,KAAK,iBAAiB,KAAK;AAAoB;AAErD,YAAMC,QAAO,WAAW,KAAK,mBAAmB,KAAK,OAAO;AAC5D,YAAM,eAAe,KAAK,eAAe;AAKzC,YAAM,0BACF,WAAWA,MAAK,QAAQ,EAAE,GAAG,GAAG,GAAG,EAAC,CAAE,KAAK,KAAK;AAEpD,UAAI,CAAC,gBAAgB,CAAC;AAAyB;AAE/C,YAAM,EAAE,OAAAC,OAAK,IAAKD;AAClB,YAAM,EAAE,WAAAE,WAAS,IAAK;AACtB,WAAK,QAAQ,KAAK,EAAE,GAAGD,QAAO,WAAAC,WAAS,CAAE;AAEzC,YAAM,EAAE,SAAS,OAAM,IAAK,KAAK;AAEjC,UAAI,CAAC,cAAc;AACf,mBAAW,QAAQ,KAAK,eAAeF,KAAI;AAC3C,aAAK,aAAa,KAAK;;AAG3B,gBAAU,OAAO,KAAK,eAAeA,KAAI;IAC7C;AAEQ,SAAA,oBAAoB,CAACD,QAAqBC,UAAmB;AACjE,WAAK,gBAAgBD;AACrB,WAAK,oBAAoB,eAAeC,OAAM,KAAK,kBAAkB;AAGrE,YAAM,OAAO,KAAK,aAAa,IAAI;IACvC;AAEQ,SAAA,kBAAkB,CAACD,QAAqBC,UAAmB;AAC/D,WAAK,IAAG;AAER,YAAM,EAAE,OAAO,cAAc,gBAAe,IAAK,KAAK;AAItD,UAAI,KAAK,oBAAoB,CAAC,KAAK,YAAY;AAC3C,2BAAmB,gBAAe;;AAEtC,UAAI,EAAE,KAAK,iBAAiB,KAAK;AAAoB;AAErD,YAAM,UAAU,WACZD,OAAM,SAAS,kBACT,KAAK,oBACL,eAAeC,OAAM,KAAK,kBAAkB,GAClD,KAAK,OAAO;AAGhB,UAAI,KAAK,cAAc,OAAO;AAC1B,cAAMD,QAAO,OAAO;;AAGxB,sBAAgB,aAAaA,QAAO,OAAO;IAC/C;AApMI,QAAI,CAAC,iBAAiB,KAAK;AAAG;AAE9B,SAAK,mBAAmB;AACxB,SAAK,WAAW;AAChB,SAAK,qBAAqB;AAC1B,SAAK,oBAAoB;AACzB,SAAK,gBAAgB,iBAAiB;AAEtC,UAAM,OAAO,iBAAiB,KAAK;AACnC,UAAM,cAAc,eAAe,MAAM,KAAK,kBAAkB;AAChE,UAAM,EAAE,MAAK,IAAK;AAElB,UAAM,EAAE,UAAS,IAAK;AAEtB,SAAK,UAAU,CAAC,EAAE,GAAG,OAAO,UAAS,CAAE;AAEvC,UAAM,EAAE,eAAc,IAAK;AAC3B,sBACI,eAAe,OAAO,WAAW,aAAa,KAAK,OAAO,CAAC;AAE/D,SAAK,kBAAkB,KACnB,gBACI,KAAK,eACL,eACA,KAAK,iBAAiB,GAE1B,gBACI,KAAK,eACL,aACA,KAAK,eAAe,GAExB,gBACI,KAAK,eACL,iBACA,KAAK,eAAe,CACvB;AAIL,QAAI,SAAS;AACT,WAAK,oBAAoB,OAAO;;;;;;EAOhC,oBAAoB,SAAoB;AAE5C,QAAI,UAAU,QAAQ;AACtB,WAAO,SAAS;AACZ,YAAM,QAAQ,iBAAiB,OAAO;AACtC,UACI,eAAe,IAAI,MAAM,SAAS,KAClC,eAAe,IAAI,MAAM,SAAS,GACpC;AACE,aAAK,gBAAgB,IAAI,SAAS;UAC9B,GAAG,QAAQ;UACX,GAAG,QAAQ;QACd,CAAA;;AAEL,gBAAU,QAAQ;;AAItB,SAAK,gBAAgB,IAAI,QAAQ;MAC7B,GAAG,OAAO;MACV,GAAG,OAAO;IACb,CAAA;AAGD,WAAO,iBAAiB,UAAU,KAAK,iBAAiB;MACpD,SAAS;MACT,SAAS;IACZ,CAAA;AAGD,WAAO,iBAAiB,UAAU,KAAK,gBAAgB;MACnD,SAAS;IACZ,CAAA;AAED,SAAK,wBAAwB,MAAK;AAC9B,aAAO,oBAAoB,UAAU,KAAK,iBAAiB;QACvD,SAAS;MACZ,CAAA;AACD,aAAO,oBAAoB,UAAU,KAAK,cAAc;IAC5D;;;;;;;;EAiBI,aAAa,QAAwB;AACzC,UAAM,UAAU,KAAK,gBAAgB,IAAI,MAAM;AAC/C,QAAI,CAAC;AAAS;AAEd,UAAM,WAAW,WAAW;AAC5B,UAAM,UAAU,WACV,EAAE,GAAG,OAAO,SAAS,GAAG,OAAO,QAAO,IACtC;MACI,GAAI,OAAmB;MACvB,GAAI,OAAmB;;AAGjC,UAAM,QAAQ,EAAE,GAAG,QAAQ,IAAI,QAAQ,GAAG,GAAG,QAAQ,IAAI,QAAQ,EAAC;AAClE,QAAI,MAAM,MAAM,KAAK,MAAM,MAAM;AAAG;AAEpC,QAAI,UAAU;AAEV,UAAI,KAAK,mBAAmB;AACxB,aAAK,kBAAkB,MAAM,KAAK,MAAM;AACxC,aAAK,kBAAkB,MAAM,KAAK,MAAM;;WAEzC;AAEH,UAAI,KAAK,QAAQ,SAAS,GAAG;AACzB,aAAK,QAAQ,CAAC,EAAE,KAAK,MAAM;AAC3B,aAAK,QAAQ,CAAC,EAAE,KAAK,MAAM;;;AAInC,SAAK,gBAAgB,IAAI,QAAQ,OAAO;AACxC,UAAM,OAAO,KAAK,aAAa,IAAI;;EAiEvC,eAAe,UAAqC;AAChD,SAAK,WAAW;;EAGpB,MAAG;AACC,SAAK,mBAAmB,KAAK,gBAAe;AAC5C,SAAK,yBAAyB,KAAK,sBAAqB;AACxD,SAAK,gBAAgB,MAAK;AAC1B,gBAAY,KAAK,WAAW;;AAEnC;AAED,SAAS,eACL,MACA,oBAA4C;AAE5C,SAAO,qBAAqB,EAAE,OAAO,mBAAmB,KAAK,KAAK,EAAC,IAAK;AAC5E;AAEA,SAAS,cAAc,GAAU,GAAQ;AACrC,SAAO,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,EAAE,IAAI,EAAE,EAAC;AACvC;AAEA,SAAS,WAAW,EAAE,MAAK,GAAe,SAA2B;AACjE,SAAO;IACH;IACA,OAAO,cAAc,OAAO,gBAAgB,OAAO,CAAC;IACpD,QAAQ,cAAc,OAAO,iBAAiB,OAAO,CAAC;IACtD,UAAU,YAAY,SAAS,GAAG;;AAE1C;AAEA,SAAS,iBAAiB,SAA2B;AACjD,SAAO,QAAQ,CAAC;AACpB;AAEA,SAAS,gBAAgB,SAA2B;AAChD,SAAO,QAAQ,QAAQ,SAAS,CAAC;AACrC;AAEA,SAAS,YAAY,SAA6B,WAAiB;AAC/D,MAAI,QAAQ,SAAS,GAAG;AACpB,WAAO,EAAE,GAAG,GAAG,GAAG,EAAC;;AAGvB,MAAI,IAAI,QAAQ,SAAS;AACzB,MAAI,mBAA4C;AAChD,QAAM,YAAY,gBAAgB,OAAO;AACzC,SAAO,KAAK,GAAG;AACX,uBAAmB,QAAQ,CAAC;AAC5B,QACI,UAAU,YAAY,iBAAiB,YACvC,sBAAsB,SAAS,GACjC;AACE;;AAEJ;;AAGJ,MAAI,CAAC,kBAAkB;AACnB,WAAO,EAAE,GAAG,GAAG,GAAG,EAAC;;AAGvB,QAAM,OAAO,sBACT,UAAU,YAAY,iBAAiB,SAAS;AAEpD,MAAI,SAAS,GAAG;AACZ,WAAO,EAAE,GAAG,GAAG,GAAG,EAAC;;AAGvB,QAAM,kBAAkB;IACpB,IAAI,UAAU,IAAI,iBAAiB,KAAK;IACxC,IAAI,UAAU,IAAI,iBAAiB,KAAK;;AAG5C,MAAI,gBAAgB,MAAM,UAAU;AAChC,oBAAgB,IAAI;;AAExB,MAAI,gBAAgB,MAAM,UAAU;AAChC,oBAAgB,IAAI;;AAGxB,SAAO;AACX;;;ACrYM,SAAU,iBACZ,OACA,EAAE,KAAK,IAAG,GACV,SAAc;AAEd,MAAI,QAAQ,UAAa,QAAQ,KAAK;AAElC,YAAQ,UACF,UAAU,KAAK,OAAO,QAAQ,GAAG,IACjC,KAAK,IAAI,OAAO,GAAG;aAClB,QAAQ,UAAa,QAAQ,KAAK;AAEzC,YAAQ,UACF,UAAU,KAAK,OAAO,QAAQ,GAAG,IACjC,KAAK,IAAI,OAAO,GAAG;;AAG7B,SAAO;AACX;SA4BgB,4BACZ,MACA,KACA,KAAY;AAEZ,SAAO;IACH,KAAK,QAAQ,SAAY,KAAK,MAAM,MAAM;IAC1C,KACI,QAAQ,SACF,KAAK,MAAM,OAAO,KAAK,MAAM,KAAK,OAClC;;AAElB;AAMgB,SAAA,wBACZ,WACA,EAAE,KAAK,MAAM,QAAQ,MAAK,GAAwB;AAElD,SAAO;IACH,GAAG,4BAA4B,UAAU,GAAG,MAAM,KAAK;IACvD,GAAG,4BAA4B,UAAU,GAAG,KAAK,MAAM;;AAE/D;AAKgB,SAAA,4BACZ,YACA,iBAAqB;AAErB,MAAI,MAAM,gBAAgB,MAAM,WAAW;AAC3C,MAAI,MAAM,gBAAgB,MAAM,WAAW;AAI3C,MACI,gBAAgB,MAAM,gBAAgB,MACtC,WAAW,MAAM,WAAW,KAC9B;AACG,KAAC,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG;;AAG3B,SAAO,EAAE,KAAK,IAAG;AACrB;AAKgB,SAAA,wBAAwB,WAAgB,gBAAmB;AACvE,SAAO;IACH,GAAG,4BAA4B,UAAU,GAAG,eAAe,CAAC;IAC5D,GAAG,4BAA4B,UAAU,GAAG,eAAe,CAAC;;AAEpE;AAMgB,SAAA,WAAW,QAAc,QAAY;AACjD,MAAI,SAAS;AACb,QAAM,eAAe,WAAW,MAAM;AACtC,QAAM,eAAe,WAAW,MAAM;AAEtC,MAAI,eAAe,cAAc;AAC7B,aAASI,SAAa,OAAO,KAAK,OAAO,MAAM,cAAc,OAAO,GAAG;aAChE,eAAe,cAAc;AACpC,aAASA,SAAa,OAAO,KAAK,OAAO,MAAM,cAAc,OAAO,GAAG;;AAG3E,SAAO,MAAM,GAAG,GAAG,MAAM;AAC7B;AAwCgB,SAAA,sBACZC,SACA,aAA0B;AAE1B,QAAM,sBAAqC,CAAA;AAE3C,MAAI,YAAY,QAAQ,QAAW;AAC/B,wBAAoB,MAAM,YAAY,MAAMA,QAAO;;AAGvD,MAAI,YAAY,QAAQ,QAAW;AAC/B,wBAAoB,MAAM,YAAY,MAAMA,QAAO;;AAGvD,SAAO;AACX;AAEO,IAAM,iBAAiB;AAId,SAAA,mBACZ,cAA2B,gBAAc;AAEzC,MAAI,gBAAgB,OAAO;AACvB,kBAAc;aACP,gBAAgB,MAAM;AAC7B,kBAAc;;AAGlB,SAAO;IACH,GAAG,mBAAmB,aAAa,QAAQ,OAAO;IAClD,GAAG,mBAAmB,aAAa,OAAO,QAAQ;;AAE1D;SAEgB,mBACZ,aACA,UACA,UAAgB;AAEhB,SAAO;IACH,KAAK,oBAAoB,aAAa,QAAQ;IAC9C,KAAK,oBAAoB,aAAa,QAAQ;;AAEtD;AAEgB,SAAA,oBACZ,aACA,OAAa;AAEb,SAAO,OAAO,gBAAgB,WACxB,cACA,YAAY,KAAiC,KAAK;AAC5D;;;AClMa,IAAA,sBAAsB,oBAAI,QAAO;IAuBjC,kCAAyB;EAkClC,YAAY,eAAyC;AA7B7C,SAAY,eAAwB;AAE5C,SAAU,aAAG;AACL,SAAgB,mBAAyB;AAEzC,SAAW,cAAU,EAAE,GAAG,GAAG,GAAG,EAAC;AAKjC,SAAW,cAAgC;AAE3C,SAAqB,wBAAG;AAKxB,SAAO,UAAG,UAAS;AAKnB,SAAkB,qBAAwB;AAK1C,SAAa,gBAAmB;AAGpC,SAAK,gBAAgB;;EAGzB,MACI,aACA,EAAE,eAAe,OAAO,kBAAiB,IAAyB,CAAA,GAAE;AAKpE,UAAM,EAAE,gBAAe,IAAK,KAAK;AACjC,QAAI,mBAAmB,gBAAgB,cAAc;AAAO;AAE5D,UAAM,iBAAiB,CAAC,UAAuB;AAI3C,UAAI,cAAc;AACd,aAAK,cAAa;AAClB,aAAK,aAAa,iBAAiB,KAAK,EAAE,KAAK;aAC5C;AACH,aAAK,eAAc;;IAE3B;AAEA,UAAM,UAAU,CAAC,OAAqB,SAAiB;AAGnD,WAAK,cAAa;AAGlB,YAAM,EAAE,MAAAC,OAAM,iBAAiB,YAAW,IAAK,KAAK,SAAQ;AAE5D,UAAIA,SAAQ,CAAC,iBAAiB;AAC1B,YAAI,KAAK;AAAc,eAAK,aAAY;AAExC,aAAK,eAAe,YAAYA,KAAI;AAGpC,YAAI,CAAC,KAAK;AAAc;;AAG5B,WAAK,qBAAqB;AAC1B,WAAK,gBAAgB;AACrB,WAAK,aAAa;AAElB,WAAK,mBAAmB;AAExB,WAAK,mBAAkB;AAEvB,UAAI,KAAK,cAAc,YAAY;AAC/B,aAAK,cAAc,WAAW,qBAAqB;AACnD,aAAK,cAAc,WAAW,SAAS;;AAM3C,eAAS,CAAC,SAAQ;AACd,YAAI,UAAU,KAAK,mBAAmB,IAAI,EAAE,IAAG,KAAM;AAKrD,YAAI,QAAQ,KAAK,OAAO,GAAG;AACvB,gBAAM,EAAE,WAAU,IAAK,KAAK;AAE5B,cAAI,cAAc,WAAW,QAAQ;AACjC,kBAAM,eAAe,WAAW,OAAO,UAAU,IAAI;AAErD,gBAAI,cAAc;AACd,oBAAM,SAAS,WAAW,YAAY;AACtC,wBAAU,UAAU,WAAW,OAAO,IAAI;;;;AAKtD,aAAK,YAAY,IAAI,IAAI;MAC7B,CAAC;AAGD,UAAI,aAAa;AACb,cAAM,WAAW,MAAM,YAAY,OAAO,IAAI,CAAC;;AAGnD,2BAAqB,KAAK,eAAe,WAAW;AAEpD,YAAM,EAAE,eAAc,IAAK,KAAK;AAChC,wBAAkB,eAAe,UAAU,aAAa,IAAI;IAChE;AAEA,UAAM,SAAS,CAAC,OAAqB,SAAiB;AAClD,WAAK,qBAAqB;AAC1B,WAAK,gBAAgB;AAErB,YAAM,EACF,iBACA,mBACA,iBACA,OAAM,IACN,KAAK,SAAQ;AAGjB,UAAI,CAAC,mBAAmB,CAAC,KAAK;AAAc;AAE5C,YAAM,EAAE,OAAM,IAAK;AAEnB,UAAI,qBAAqB,KAAK,qBAAqB,MAAM;AACrD,aAAK,mBAAmB,oBAAoB,MAAM;AAGlD,YAAI,KAAK,qBAAqB,MAAM;AAChC,6BAAmB,gBAAgB,KAAK,gBAAgB;;AAG5D;;AAIJ,WAAK,WAAW,KAAK,KAAK,OAAO,MAAM;AACvC,WAAK,WAAW,KAAK,KAAK,OAAO,MAAM;AAQvC,WAAK,cAAc,OAAM;AAMzB,gBAAU,OAAO,OAAO,IAAI;IAChC;AAEA,UAAM,eAAe,CAAC,OAAqB,SAAiB;AACxD,WAAK,qBAAqB;AAC1B,WAAK,gBAAgB;AAErB,WAAK,KAAK,OAAO,IAAI;AAErB,WAAK,qBAAqB;AAC1B,WAAK,gBAAgB;IACzB;AAEA,UAAM,kBAAkB,MACpB,SACI,CAAC,SACG,KAAK,kBAAkB,IAAI,MAAM,YACjC,KAAK,mBAAmB,IAAI,EAAE,WAAW,KAAI,CAAE;AAG3D,UAAM,EAAE,iBAAgB,IAAK,KAAK,SAAQ;AAC1C,SAAK,aAAa,IAAI,WAClB,aACA;MACI;MACA;MACA;MACA;MACA;OAEJ;MACI,oBAAoB,KAAK,cAAc,sBAAqB;MAC5D;MACA;MACA,eAAe,iBAAiB,KAAK,aAAa;MAClD,SAAS,KAAK,cAAc;IAC/B,CAAA;;;;;EAOT,KAAK,OAAsB,SAAiB;AACxC,UAAM,aAAa,SAAS,KAAK;AACjC,UAAM,eAAe,WAAW,KAAK;AAErC,UAAM,aAAa,KAAK;AACxB,SAAK,OAAM;AACX,QAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC;AAAY;AAEjD,UAAM,EAAE,SAAQ,IAAK;AACrB,SAAK,eAAe,QAAQ;AAE5B,UAAM,EAAE,UAAS,IAAK,KAAK,SAAQ;AACnC,QAAI,WAAW;AACX,YAAM,WAAW,MAAM,UAAU,YAAY,YAAY,CAAC;;;;;;EAOlE,SAAM;AACF,SAAK,aAAa;AAElB,UAAM,EAAE,YAAY,eAAc,IAAK,KAAK;AAE5C,QAAI,YAAY;AACZ,iBAAW,qBAAqB;;AAGpC,SAAK,cAAa;AAElB,UAAM,EAAE,gBAAe,IAAK,KAAK,SAAQ;AAEzC,QAAI,CAAC,mBAAmB,KAAK,cAAc;AACvC,WAAK,aAAY;AACjB,WAAK,eAAe;;AAGxB,sBAAkB,eAAe,UAAU,aAAa,KAAK;;;;;;;;EASjE,gBAAa;AACT,SAAK,cAAc,KAAK,WAAW,IAAG;AACtC,SAAK,aAAa;;EAGd,WAAW,MAAqB,QAAe,QAAc;AACjE,UAAM,EAAE,MAAAA,MAAI,IAAK,KAAK,SAAQ;AAG9B,QAAI,CAAC,UAAU,CAAC,WAAW,MAAMA,OAAM,KAAK,gBAAgB;AAAG;AAE/D,UAAM,YAAY,KAAK,mBAAmB,IAAI;AAC9C,QAAI,OAAO,KAAK,YAAY,IAAI,IAAI,OAAO,IAAI;AAG/C,QAAI,KAAK,eAAe,KAAK,YAAY,IAAI,GAAG;AAC5C,aAAO,iBACH,MACA,KAAK,YAAY,IAAI,GACrB,KAAK,QAAQ,IAAI,CAAC;;AAI1B,cAAU,IAAI,IAAI;;EAGd,qBAAkB;AACtB,UAAM,EAAE,iBAAiB,YAAW,IAAK,KAAK,SAAQ;AAEtD,UAAMC,UACF,KAAK,cAAc,cACnB,CAAC,KAAK,cAAc,WAAW,SACzB,KAAK,cAAc,WAAW,QAAQ,KAAK,IAC3C,KAAK,cAAc,YAAY;AAEzC,UAAM,kBAAkB,KAAK;AAE7B,QAAI,mBAAmB,YAAY,eAAe,GAAG;AACjD,UAAI,CAAC,KAAK,aAAa;AACnB,aAAK,cAAc,KAAK,sBAAqB;;WAE9C;AACH,UAAI,mBAAmBA,SAAQ;AAC3B,aAAK,cAAc,wBACfA,QAAO,WACP,eAAe;aAEhB;AACH,aAAK,cAAc;;;AAI3B,SAAK,UAAU,mBAAmB,WAAW;AAM7C,QACI,oBAAoB,KAAK,eACzBA,WACA,KAAK,eACL,CAAC,KAAK,uBACR;AACE,eAAS,CAAC,SAAQ;AACd,YACI,KAAK,gBAAgB,SACrB,KAAK,mBAAmB,IAAI,GAC9B;AACE,eAAK,YAAY,IAAI,IAAI,sBACrBA,QAAO,UAAU,IAAI,GACrB,KAAK,YAAY,IAAI,CAAC;;MAGlC,CAAC;;;EAID,wBAAqB;AACzB,UAAM,EAAE,iBAAiB,aAAa,yBAAwB,IAC1D,KAAK,SAAQ;AACjB,QAAI,CAAC,eAAe,CAAC,YAAY,WAAW;AAAG,aAAO;AAEtD,UAAM,qBAAqB,YAAY;AAEvC,cACI,uBAAuB,MACvB,0GACA,sBAAsB;AAG1B,UAAM,EAAE,WAAU,IAAK,KAAK;AAG5B,QAAI,CAAC,cAAc,CAAC,WAAW;AAAQ,aAAO;AAE9C,UAAM,iBAAiB,eACnB,oBACA,WAAW,MACX,KAAK,cAAc,sBAAqB,CAAE;AAG9C,QAAI,sBAAsB,wBACtB,WAAW,OAAO,WAClB,cAAc;AAOlB,QAAI,0BAA0B;AAC1B,YAAM,kBAAkB,yBACpB,wBAAwB,mBAAmB,CAAC;AAGhD,WAAK,wBAAwB,CAAC,CAAC;AAE/B,UAAI,iBAAiB;AACjB,8BAAsB,wBAAwB,eAAe;;;AAIrE,WAAO;;EAGH,eAAe,UAAe;AAClC,UAAM,EACF,MAAAD,OACA,cACA,aACA,gBACA,kBACA,oBAAmB,IACnB,KAAK,SAAQ;AAEjB,UAAM,cAA4C,KAAK,eAAe,CAAA;AAEtE,UAAM,qBAAqB,SAAS,CAAC,SAAQ;AACzC,UAAI,CAAC,WAAW,MAAMA,OAAM,KAAK,gBAAgB,GAAG;AAChD;;AAGJ,UAAI,aAAc,eAAe,YAAY,IAAI,KAAM,CAAA;AAEvD,UAAI;AAAkB,qBAAa,EAAE,KAAK,GAAG,KAAK,EAAC;AAQnD,YAAM,kBAAkB,cAAc,MAAM;AAC5C,YAAM,gBAAgB,cAAc,KAAK;AAEzC,YAAM,UAAsB;QACxB,MAAM;QACN,UAAU,eAAe,SAAS,IAAI,IAAI;QAC1C;QACA;QACA,cAAc;QACd,WAAW;QACX,WAAW;QACX,GAAG;QACH,GAAG;;AAMP,aAAO,KAAK,wBAAwB,MAAM,OAAO;IACrD,CAAC;AAGD,WAAO,QAAQ,IAAI,kBAAkB,EAAE,KAAK,mBAAmB;;EAG3D,wBACJ,MACA,YAAsB;AAEtB,UAAM,YAAY,KAAK,mBAAmB,IAAI;AAE9C,yBAAqB,KAAK,eAAe,IAAI;AAE7C,WAAO,UAAU,MACb,mBACI,MACA,WACA,GACA,YACA,KAAK,eACL,KAAK,CACR;;EAID,gBAAa;AACjB,aAAS,CAAC,SAAS,KAAK,mBAAmB,IAAI,EAAE,KAAI,CAAE;;EAGnD,iBAAc;AAClB,aAAS,CAAC,SAAS,KAAK,mBAAmB,IAAI,EAAE,WAAW,MAAK,CAAE;;EAG/D,kBAAkB,MAAmB;AACzC,WAAO,KAAK,mBAAmB,IAAI,EAAE,WAAW;;;;;;;;EAS5C,mBAAmB,MAAmB;AAC1C,UAAM,UACF,QAAQ,KAAK,YAAW,CAAE;AAC9B,UAAM,QAAQ,KAAK,cAAc,SAAQ;AACzC,UAAM,sBAAsB,MAAM,OAAO;AAEzC,WAAO,sBACD,sBACA,KAAK,cAAc,SACf,OACC,MAAM,UACD,MAAM,QAAQ,IAAkC,IAChD,WAAc,CAAC;;EAI3B,aAAa,OAAY;AAC7B,aAAS,CAAC,SAAQ;AACd,YAAM,EAAE,MAAAA,MAAI,IAAK,KAAK,SAAQ;AAG9B,UAAI,CAAC,WAAW,MAAMA,OAAM,KAAK,gBAAgB;AAAG;AAEpD,YAAM,EAAE,WAAU,IAAK,KAAK;AAC5B,YAAM,YAAY,KAAK,mBAAmB,IAAI;AAE9C,UAAI,cAAc,WAAW,QAAQ;AACjC,cAAM,EAAE,KAAK,IAAG,IAAK,WAAW,OAAO,UAAU,IAAI;AAQrD,cAAM,UAAU,UAAU,IAAG,KAAM;AAEnC,kBAAU,IAAI,MAAM,IAAI,IAAI,UAAU,KAAK,KAAK,GAAG,IAAI,OAAO;;IAEtE,CAAC;;;;;;;EAQL,iCAA8B;AAC1B,QAAI,CAAC,KAAK,cAAc;AAAS;AAEjC,UAAM,EAAE,MAAAA,OAAM,gBAAe,IAAK,KAAK,SAAQ;AAC/C,UAAM,EAAE,WAAU,IAAK,KAAK;AAC5B,QAAI,CAAC,YAAY,eAAe,KAAK,CAAC,cAAc,CAAC,KAAK;AACtD;AAMJ,SAAK,cAAa;AAMlB,UAAM,cAAc,EAAE,GAAG,GAAG,GAAG,EAAC;AAChC,aAAS,CAAC,SAAQ;AACd,YAAM,YAAY,KAAK,mBAAmB,IAAI;AAC9C,UAAI,aAAa,KAAK,gBAAgB,OAAO;AACzC,cAAM,SAAS,UAAU,IAAG;AAC5B,oBAAY,IAAI,IAAI,WAChB,EAAE,KAAK,QAAQ,KAAK,OAAM,GAC1B,KAAK,YAAY,IAAI,CAAS;;IAG1C,CAAC;AAKD,UAAM,EAAE,kBAAiB,IAAK,KAAK,cAAc,SAAQ;AACzD,SAAK,cAAc,QAAQ,MAAM,YAAY,oBACvC,kBAAkB,CAAA,GAAI,EAAE,IACxB;AACN,eAAW,QAAQ,WAAW,KAAK,aAAY;AAC/C,eAAW,aAAY;AACvB,SAAK,mBAAkB;AAMvB,aAAS,CAAC,SAAQ;AACd,UAAI,CAAC,WAAW,MAAMA,OAAM,IAAI;AAAG;AAKnC,YAAM,YAAY,KAAK,mBAAmB,IAAI;AAC9C,YAAM,EAAE,KAAK,IAAG,IAAM,KAAK,YACvB,IAAI;AAER,gBAAU,IAAI,UAAU,KAAK,KAAK,YAAY,IAAI,CAAC,CAAC;IACxD,CAAC;;EAGL,eAAY;AACR,QAAI,CAAC,KAAK,cAAc;AAAS;AACjC,wBAAoB,IAAI,KAAK,eAAe,IAAI;AAChD,UAAM,UAAU,KAAK,cAAc;AAKnC,UAAM,sBAAsB,gBACxB,SACA,eACA,CAAC,UAAS;AACN,YAAM,EAAE,MAAAA,OAAM,eAAe,KAAI,IAAK,KAAK,SAAQ;AACnD,YAAM,SAAS,MAAM;AAOrB,YAAM,oCACF,WAAW,WACX,4BAA4B,MAAM;AAEtC,UAAIA,SAAQ,gBAAgB,CAAC,mCAAmC;AAC5D,aAAK,MAAM,KAAK;;IAExB,CAAC;AAGL,UAAM,yBAAyB,MAAK;AAChC,YAAM,EAAE,gBAAe,IAAK,KAAK,SAAQ;AACzC,UAAI,YAAY,eAAe,KAAK,gBAAgB,SAAS;AACzD,aAAK,cAAc,KAAK,sBAAqB;;IAErD;AAEA,UAAM,EAAE,WAAU,IAAK,KAAK;AAE5B,UAAM,4BAA4B,WAAY,iBAC1C,WACA,sBAAsB;AAG1B,QAAI,cAAc,CAAC,WAAY,QAAQ;AACnC,iBAAW,QAAQ,WAAW,KAAK,aAAY;AAC/C,iBAAW,aAAY;;AAG3B,UAAM,KAAK,sBAAsB;AAMjC,UAAM,qBAAqB,YAAY,QAAQ,UAAU,MACrD,KAAK,+BAA8B,CAAE;AAOzC,UAAM,2BAA2B,WAAY,iBACzC,cACC,CAAC,EAAE,OAAO,iBAAgB,MAAwB;AAC/C,UAAI,KAAK,cAAc,kBAAkB;AACrC,iBAAS,CAAC,SAAQ;AACd,gBAAM,cAAc,KAAK,mBAAmB,IAAI;AAChD,cAAI,CAAC;AAAa;AAElB,eAAK,YAAY,IAAI,KAAK,MAAM,IAAI,EAAE;AACtC,sBAAY,IACR,YAAY,IAAG,IAAK,MAAM,IAAI,EAAE,SAAS;QAEjD,CAAC;AAED,aAAK,cAAc,OAAM;;MAEhC;AAGL,WAAO,MAAK;AACR,yBAAkB;AAClB,0BAAmB;AACnB,gCAAyB;AACzB,kCAA4B,yBAAwB;IACxD;;EAGJ,WAAQ;AACJ,UAAM,QAAQ,KAAK,cAAc,SAAQ;AACzC,UAAM,EACF,MAAAA,QAAO,OACP,oBAAoB,OACpB,kBAAkB,OAClB,kBAAkB,OAClB,cAAc,gBACd,eAAe,KAAI,IACnB;AACJ,WAAO;MACH,GAAG;MACH,MAAAA;MACA;MACA;MACA;MACA;MACA;;;AAGX;AAED,SAAS,WACL,WACAA,OACA,kBAAsC;AAEtC,UACKA,UAAS,QAAQA,UAAS,eAC1B,qBAAqB,QAAQ,qBAAqB;AAE3D;AASA,SAAS,oBACL,QACA,gBAAgB,IAAE;AAElB,MAAI,YAAkC;AAEtC,MAAI,KAAK,IAAI,OAAO,CAAC,IAAI,eAAe;AACpC,gBAAY;aACL,KAAK,IAAI,OAAO,CAAC,IAAI,eAAe;AAC3C,gBAAY;;AAGhB,SAAO;AACX;;;AC5wBM,IAAO,cAAP,cAA2B,QAAoB;EAMjD,YAAY,MAAgC;AACxC,UAAM,IAAI;AAJd,SAAmB,sBAAa;AAChC,SAAe,kBAAa;AAIxB,SAAK,WAAW,IAAI,0BAA0B,IAAI;;EAGtD,QAAK;AAGD,UAAM,EAAE,aAAY,IAAK,KAAK,KAAK,SAAQ;AAE3C,QAAI,cAAc;AACd,WAAK,sBAAsB,aAAa,UAAU,KAAK,QAAQ;;AAGnE,SAAK,kBAAkB,KAAK,SAAS,aAAY,KAAM;;EAG3D,SAAM;AACF,UAAM,EAAE,aAAY,IAAK,KAAK,KAAK,SAAQ;AAC3C,UAAM,EAAE,cAAc,iBAAgB,IAAK,KAAK,KAAK,aAAa,CAAA;AAElE,QAAI,iBAAiB,kBAAkB;AACnC,WAAK,oBAAmB;AACxB,UAAI,cAAc;AACd,aAAK,sBAAsB,aAAa,UAAU,KAAK,QAAQ;;;;EAK3E,UAAO;AACH,SAAK,oBAAmB;AACxB,SAAK,gBAAe;AAMpB,SAAK,SAAS,cAAa;;AAElC;;;AC1CD,IAAM,eACF,CAAC,YAA8B,CAAC,OAAqB,SAAiB;AAClE,MAAI,SAAS;AACT,UAAM,WAAW,MAAM,QAAQ,OAAO,IAAI,CAAC;;AAEnD;AAEE,IAAO,aAAP,cAA0B,QAAgB;EAAhD,cAAA;;AAGY,SAAyB,4BAAa;;EAE9C,cAAc,kBAA8B;AACxC,SAAK,UAAU,IAAI,WACf,kBACA,KAAK,kBAAiB,GACtB;MACI,oBAAoB,KAAK,KAAK,sBAAqB;MACnD,eAAe,iBAAiB,KAAK,IAAI;IAC5C,CAAA;;EAIT,oBAAiB;AACb,UAAM,EAAE,mBAAmB,YAAY,OAAO,SAAQ,IAClD,KAAK,KAAK,SAAQ;AAEtB,WAAO;MACH,gBAAgB,aAAa,iBAAiB;MAC9C,SAAS,aAAa,UAAU;MAChC,QAAQ;MACR,OAAO,CAAC,OAAqB,SAAiB;AAC1C,eAAO,KAAK;AACZ,YAAI,UAAU;AACV,gBAAM,WAAW,MAAM,SAAS,OAAO,IAAI,CAAC;;;;;EAM5D,QAAK;AACD,SAAK,4BAA4B,gBAC7B,KAAK,KAAK,SACV,eACA,CAAC,UAAwB,KAAK,cAAc,KAAK,CAAC;;EAI1D,SAAM;AACF,SAAK,WAAW,KAAK,QAAQ,eAAe,KAAK,kBAAiB,CAAE;;EAGxE,UAAO;AACH,SAAK,0BAAyB;AAC9B,SAAK,WAAW,KAAK,QAAQ,IAAG;;AAEvC;A;;;;ACjCD,IAAA,sBAAA;AAEA,IAAA,2BAAA,cAAA,wBAAA;;;;;;;AAOQ,UAAA,EAAA,eAAA,aAAA,mBAAA,SAAA,IAAA,KAAA;AAEA,UAAA,EAAA,WAAA,IAAA;;;AAG2B,oBAAA,MAAA,IAAA,UAAA;;AAGnB,0BAAA,SAAA,UAAA;;;AAIA,mBAAA,KAAA,UAAA;;AAGJ,iBAAA,iBAAA,qBAAA,MAAA;;MAEA,CAAA;;;QAGI,gBAAA,MAAA,KAAA,aAAA;MACH,CAAA;;AAGL,0BAAA,iBAAA;;EAGJ,wBAAA,WAAA;AACI,UAAA,EAAA,kBAAA,eAAA,MAAAE,OAAA,WAAAC,WAAA,IAAA,KAAA;AACA,UAAA,EAAA,WAAA,IAAA;AAEA,QAAA,CAAA;AAAiB,aAAA;AASjB,eAAA,YAAAA;;AAIA,QAAAD,4DAGI,qBAAA,UACA,UAAA,cAAAC,YAAA;;;;;AAOJ,QAAA,UAAA,cAAAA,YAAA;;;iBAGW,CAAA,WAAA,SAAA,GAAA;AAMH,cAAA,WAAA,MAAA;AACI,gBAAA,QAAA,WAAA,SAAA;;;;QAIJ,CAAA;;;AAIR,WAAA;;;;;AAMI,iBAAA,KAAA,UAAA;AAEA,gBAAA,WAAA,MAAA;;;;MAIA,CAAA;;;;AAKJ,UAAA,EAAA,eAAA,aAAA,mBAAA,eAAA,IAAA,KAAA;AAKA,UAAA,EAAA,WAAA,IAAA;;;;AAMI,UAAA,eAAA,YAAA;AACI,oBAAA,MAAA,OAAA,UAAA;AACJ,UAAA,kBAAA,eAAA;AACI,uBAAA,WAAA,UAAA;;;;AAKR,UAAA,EAAA,aAAA,IAAA,KAAA;;;;AAKA,WAAA;;AAEP;AAEK,SAAA,cAAA,OAAA;;AAIF,QAAA,kBAAA,0BAAA,kBAAA;;AAWJ;;;ACtKa,IAAA,OAAwB;EACjC,KAAK;IACD,SAAS;EACZ;EACD,MAAM;IACF,SAAS;IACT,gBAAgB;IAChB;EACH;;;;ACXL,SAAS,iBACL,MACA,OACA,WAA0B;AAE1B,QAAM,EAAE,MAAK,IAAK;AAElB,MAAI,KAAK,kBAAkB,MAAM,YAAY;AACzC,SAAK,eAAe,UAAU,cAAc,cAAc,OAAO;;AAGrE,QAAM,YAAa,YAAY;AAC/B,QAAM,WAAW,MAAM,SAAS;AAChC,MAAI,UAAU;AACV,UAAM,WAAW,MAAM,SAAS,OAAO,iBAAiB,KAAK,CAAC,CAAC;;AAEvE;AAEM,IAAO,eAAP,cAA4B,QAAgB;EAC9C,QAAK;AACD,UAAM,EAAE,QAAO,IAAK,KAAK;AACzB,QAAI,CAAC;AAAS;AAEd,SAAK,UAAU,MAAM,SAAS,CAAC,UAAU,eAAc;AACnD,uBAAiB,KAAK,MAAM,YAAY,OAAO;AAE/C,aAAO,CAAC,aAAa,iBAAiB,KAAK,MAAM,UAAU,KAAK;IACpE,CAAC;;EAGL,UAAO;EAAA;AACV;;;AC/BK,IAAO,eAAP,cAA4B,QAAgB;EAAlD,cAAA;;AACY,SAAQ,WAAG;;EAEnB,UAAO;AACH,QAAI,iBAAiB;AAQrB,QAAI;AACA,uBAAiB,KAAK,KAAK,QAAS,QAAQ,gBAAgB;aACvD,GAAG;AACR,uBAAiB;;AAGrB,QAAI,CAAC,kBAAkB,CAAC,KAAK,KAAK;AAAgB;AAElD,SAAK,KAAK,eAAe,UAAU,cAAc,IAAI;AACrD,SAAK,WAAW;;EAGpB,SAAM;AACF,QAAI,CAAC,KAAK,YAAY,CAAC,KAAK,KAAK;AAAgB;AACjD,SAAK,KAAK,eAAe,UAAU,cAAc,KAAK;AACtD,SAAK,WAAW;;EAGpB,QAAK;AACD,SAAK,UAAU,KACX,YAAY,KAAK,KAAK,SAAU,SAAS,MAAM,KAAK,QAAO,CAAE,GAC7D,YAAY,KAAK,KAAK,SAAU,QAAQ,MAAM,KAAK,OAAM,CAAE,CAAC;;EAIpE,UAAO;EAAA;AACV;;;ACtCD,SAAS,iBACL,MACA,OACA,WAAqC;AAErC,QAAM,EAAE,MAAK,IAAK;AAElB,MAAI,KAAK,mBAAmB,qBAAqB,KAAK,QAAQ,UAAU;AACpE;;AAGJ,MAAI,KAAK,kBAAkB,MAAM,UAAU;AACvC,SAAK,eAAe,UAAU,YAAY,cAAc,OAAO;;AAGnE,QAAM,YAAa,WAAW,cAAc,QAAQ,KAAK;AAKzD,QAAM,WAAW,MAAM,SAAS;AAChC,MAAI,UAAU;AACV,UAAM,WAAW,MAAM,SAAS,OAAO,iBAAiB,KAAK,CAAC,CAAC;;AAEvE;AAEM,IAAO,eAAP,cAA4B,QAAgB;EAC9C,QAAK;AACD,UAAM,EAAE,QAAO,IAAK,KAAK;AACzB,QAAI,CAAC;AAAS;AAEd,SAAK,UAAU,MACX,SACA,CAAC,UAAU,eAAc;AACrB,uBAAiB,KAAK,MAAM,YAAY,OAAO;AAE/C,aAAO,CAAC,UAAU,EAAE,QAAO,MACvB,iBACI,KAAK,MACL,UACA,UAAU,QAAQ,QAAQ;IAEtC,GACA,EAAE,iBAAiB,KAAK,KAAK,MAAM,gBAAe,CAAE;;EAI5D,UAAO;EAAA;AACV;;;ACxCD,IAAM,oBAAoB,oBAAI,QAAO;AAOrC,IAAM,YAAY,oBAAI,QAAO;AAK7B,IAAM,uBAAuB,CAAC,UAAoC;AAC9D,QAAM,WAAW,kBAAkB,IAAI,MAAM,MAAM;AACnD,cAAY,SAAS,KAAK;AAC9B;AAEA,IAAM,2BAAyD,CAAC,YAAW;AACvE,UAAQ,QAAQ,oBAAoB;AACxC;AAEA,SAAS,yBAAyB,EAC9B,MACA,GAAG,QAAO,GACa;AACvB,QAAM,aAAa,QAAQ;AAK3B,MAAI,CAAC,UAAU,IAAI,UAAU,GAAG;AAC5B,cAAU,IAAI,YAAY,CAAA,CAAE;;AAEhC,QAAM,gBAAgB,UAAU,IAAI,UAAU;AAE9C,QAAM,MAAM,KAAK,UAAU,OAAO;AAMlC,MAAI,CAAC,cAAc,GAAG,GAAG;AACrB,kBAAc,GAAG,IAAI,IAAI,qBACrB,0BACA,EAAE,MAAM,GAAG,QAAO,CAAE;;AAI5B,SAAO,cAAc,GAAG;AAC5B;SAEgB,oBACZ,SACA,SACA,UAA6B;AAE7B,QAAM,4BAA4B,yBAAyB,OAAO;AAElE,oBAAkB,IAAI,SAAS,QAAQ;AACvC,4BAA0B,QAAQ,OAAO;AAEzC,SAAO,MAAK;AACR,sBAAkB,OAAO,OAAO;AAChC,8BAA0B,UAAU,OAAO;EAC/C;AACJ;;;ACxEA,IAAM,iBAAiB;EACnB,MAAM;EACN,KAAK;;AAGH,IAAO,gBAAP,cAA6B,QAAgB;EAAnD,cAAA;;AACY,SAAc,iBAAG;AAEjB,SAAQ,WAAG;;EAEX,gBAAa;AACjB,SAAK,QAAO;AAEZ,UAAM,EAAE,WAAW,CAAA,EAAE,IAAK,KAAK,KAAK,SAAQ;AAC5C,UAAM,EAAE,MAAM,QAAQ,YAAY,SAAS,QAAQ,KAAI,IAAK;AAE5D,UAAM,UAAU;MACZ,MAAM,OAAO,KAAK,UAAU;MAC5B;MACA,WACI,OAAO,WAAW,WAAW,SAAS,eAAe,MAAM;;AAGnE,UAAM,uBAAuB,CAAC,UAAoC;AAC9D,YAAM,EAAE,eAAc,IAAK;AAK3B,UAAI,KAAK,aAAa;AAAgB;AAEtC,WAAK,WAAW;AAMhB,UAAI,QAAQ,CAAC,kBAAkB,KAAK,gBAAgB;AAChD;iBACO,gBAAgB;AACvB,aAAK,iBAAiB;;AAG1B,UAAI,KAAK,KAAK,gBAAgB;AAC1B,aAAK,KAAK,eAAe,UACrB,eACA,cAAc;;AAQtB,YAAM,EAAE,iBAAiB,gBAAe,IAAK,KAAK,KAAK,SAAQ;AAC/D,YAAM,WAAW,iBAAiB,kBAAkB;AACpD,kBAAY,SAAS,KAAK;IAC9B;AAEA,WAAO,oBACH,KAAK,KAAK,SACV,SACA,oBAAoB;;EAI5B,QAAK;AACD,SAAK,cAAa;;EAGtB,SAAM;AACF,QAAI,OAAO,yBAAyB;AAAa;AAEjD,UAAM,EAAE,OAAO,UAAS,IAAK,KAAK;AAClC,UAAM,oBAAoB,CAAC,UAAU,UAAU,MAAM,EAAE,KACnD,yBAAyB,OAAO,SAAS,CAAC;AAG9C,QAAI,mBAAmB;AACnB,WAAK,cAAa;;;EAI1B,UAAO;EAAA;AACV;AAED,SAAS,yBACL,EAAE,WAAW,CAAA,EAAE,GACf,EAAE,UAAU,eAAe,CAAA,EAAE,IAAkB,CAAA,GAAE;AAEjD,SAAO,CAAC,SACJ,SAAS,IAAI,MAAM,aAAa,IAAI;AAC5C;;;AC1Fa,IAAA,oBAAqC;EAC9C,QAAQ;IACJ,SAAS;EACZ;EACD,KAAK;IACD,SAAS;EACZ;EACD,OAAO;IACH,SAAS;EACZ;EACD,OAAO;IACH,SAAS;EACZ;;;;ACdQ,IAAA,SAA0B;EACnC,QAAQ;IACJ,gBAAgB;IAChB;EACH;;;;ACHQ,IAAA,gBAAgB;EACzB,GAAG;EACH,GAAG;EACH,GAAG;EACH,GAAG;;",
  "names": ["isPresent", "id", "isPresent", "Component", "event", "info", "point", "timestamp", "calcProgress", "layout", "drag", "layout", "drag", "isPresent"]
}
